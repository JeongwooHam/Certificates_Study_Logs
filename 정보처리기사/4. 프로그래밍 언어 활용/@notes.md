232-314

# 🌟 배치 프로그램

- 사용자와의 상호 작용 없이 여러 작업들을 미리 정해진 일련의 순서에 따라 일괄적으로 처리하는 것

## 배치 프로그램의 필수 요소

> **대용량 데이터**

- 대량의 데이터를 가져오거나, 전달하거나, 계산하는 등의 처리가 가능해야 함

> **자동화**

- 심각한 오류가 발생하는 상황을 제외하고는 사용자의 개입 없이 수행되어야 함

> **견고성**

- 잘못된 데이터나 데이터 중복 등의 상황으로 중단되는 일 없이 수행되어야 함

> **안정성/신뢰성**

- 오류가 발생하면 오류의 발생 위치, 시간 등을 추적할 수 있어야 함

> **성능**

- 다른 응용 프로그램의 수행을 방해하지 않아야 하고, 지정된 시간 내에 처리가 완료되어야 함

# 🌟 변수 (Variable)

## 변수의 개요

- 컴퓨터가 명령을 처리하는 도중 발생하는 값을 저장하기 위한 공간
- 변할 수 있는 값
- 저장하는 값에 따라 정수형, 실수형, 문자형, 포인터형 등으로 구분한다.

## 변수명 작성 규칙

- 영문자, 숫자, `_`(under bar)를 사용할 수 있다.
- 첫 글자는 영문자나 `_`(under bar)로 시작해야 하며, 숫자는 올 수 없다.
- 글자 수에 제한이 없다.
- 공백이나 `*`, `+`, `-`, `/` 등의 특수문자를 사용할 수 없다.
- 대·소문자를 구분한다.
- 예약어를 변수명으로 사용할 수 없다.
- 변수 선언 시 문장 끝에 반드시 세미콜론(;)을 붙여야한다.
- 변수 선언 시 변수명에 데이터 타입을 명시하는 것을 **_헝가리안 표기법_**(Hungarian Notation)이라고 한다.

# 🌟 가비지 콜렉터 (GC)

> **Garbage Collection**

- 변수를 선언만 하고 사용하지 않으면 이 변수들이 점유한 메모리 공간은 다른 프로그램들이 사용할 수 없게 된다.
  ➡️ 선언만 하고 사용하지 않는 변수들이 점유한 메모리 공간을 강제로 해제하여 다른 프로그램들이 사용할 수 있도록 하는 것

> **Garbage Collector**

- Garbage Collection 기능을 수행하는 모듈

# 🌟 C언어

## C/C++의 데이터 타입 크기 및 기억 범위

![image](https://github.com/JeongwooHam/FE_Study_Logs/assets/123251211/7c309a27-257a-4fe7-8d7b-1881cd0379de)

## C언어의 구조체

- 배열이 자료의 형과 크기가 **동일한** 변수의 모임이라면 구조체는 자료의 종류가 **다른** 변수의 모임
- 예: 이름, 직위, 급여 등의 필드가 필요한 사원 자료를 하나의 단위로 관리하려는 경우 - 이름과 직위는 문자, 급여는 숫자와 같이 문자와 숫자가 혼용되므로 배열로는 처리할 수 없다.
  ➡️ 이런 경우 구조체를 사용하면 간단하게 처리할 수 있다.
  • 구조체를 정의한다는 것은 int나 char 같은 자료형을 하나 만드는 것을 의미한다.
  • 구조체는 ‘**_structure_**(구조)’의 약어인 ‘**_struct_**’를 사용하여 정의한다.

### 구조체 정의 예

```c
struct sawon {
char name[10];
char position[10];
int pay;
}
```

## 서식 문자열

| 서식 문자열 | 의미                                             |
| :---------: | :----------------------------------------------- |
|    `%d`     | 정수형 10진수를 입·출력하기 위해 지정함          |
|    `%u`     | 부호없는 정수형 10진수를 입·출력하기 위해 지정함 |
|    `%o`     | 정수형 8진수를 입·출력하기 위해 지정함           |
|    `%x`     | 정수형 16진수를 입·출력하기 위해 지정함          |
|    `%c`     | 문자를 입·출력하기 위해 지정함                   |
|    `%s`     | 문자열을 입·출력하기 위해 지정함                 |
|    `%f`     | 소수점을 포함하는 실수를 입·출력하기 위해 지정함 |
|    `%e`     | 지수형 실수를 입·출력하기 위해 지정함            |
|    `%ld`    | long형 10진수를 입·출력하기 위해 지정함          |
|    `%lo`    | long형 8진수를 입·출력하기 위해 지정함           |
|    `%lx`    | long형 16진수를 입·출력하기 위해 지정함          |
|    `%p`     | 주소를 16진수로 입·출력하기 위해 지정함          |

## 주요 제어 문자

![image](https://github.com/JeongwooHam/FE_Study_Logs/assets/123251211/4b966d15-50bb-44ce-a3fa-a6ddc6f4b554)

## `scanf()`

- C언어의 표준 입력 함수
- 키보드로 입력받아 변수에 저장하는 함수

### 형식

> `scanf (서식 문자열, 변수의 주소)`

- 서식 문자열
  - 입력받을 데이터의 자료형을 지정함
- 변수의 주소
  - 데이터를 입력받을 변수를 적는다.
  - 변수의 주소로 입력받아야하기 때문에 변수에 주소연산자 `&`를붙임
- 예: `scanf(" %3d ", &a);`
  - `%` : 서식 문자임을 지정
  - `3` : 입력 자릿수를 3자리로 지정
  - `d` : 10진수로 입력
  - `&a` : 입력받은 데이터를 변수 a의 주소에 저장

### 특징

- 입력받을 데이터의 자료형, 자릿수 등을 지정할 수 있다.
- 한 번에 여러 개의 데이터를 입력 받을 수 있다.
- 서식 문자열과 변수의 자료형은 일치해야 한다.
  - `scanf("%d %f", &i, &j);` ➡️ ‘%d’와 i, “%f”와 j는 자료형이 일치해야 한다.

## `printf()`

- C언어의 표준 출력 함수
- 인수로 주어진 값을 화면에 출력하는 함수

### 형식

> `printf (서식 문자열, 변수)`

- 서식 문자열
  - 변수의 자료형에 맞는 서식 문자열을 입력함
- 변수의 주소
  - 서식 문자열의 순서에 맞게 출력할 변수를 적음
  - `scanf( )`와 달리 주소 연산자 `&`를 붙이지 않음
- 예: `sprintf("%-8.2f", 200.2);` ➡️ `200.20VV`
  - `%` : 서식 문자임을 지정
  - `-` : 왼쪽부터 출력
  - `8` : 출력 자릿수를 8자리로 지정
  - `2` : 소수점 이하를 2자리로 지정
  - `f` : 실수로 출력

## 문자열 처리 함수

### `strlen(s)`

- s의 길이

### `strcpy(s1, s2)`

- s2를 s1으로 복사한다.

### `strcat(s1, s1)`

- s1과 s2를 연결한다.

### `strrev(s)`

- s를 거꾸로 변환한다.

# 📍 연산자

## 산술 연산자

- 가, 감, 승, 제 등의 산술 계산에 사용되는 연산자
- 일반 산술식과 달리 한 변수의 값을 증가하거나 감소시키는 증감 연산자가 있다.

### 증감 연산자

- 증가: `++`, 감소: `--`

> **전치**

- 변수 앞에 증감 연산자가 오는 형태
- 먼저 변수의 값을 증감시킨 후 변수를 연산에 사용함(`++a`, `--a`)
  > **후치**
- 변수 뒤에 증감 연산자가 오는 형태
- 먼저 변수를 연산에 사용한 후 변수의 값을 증감시킴(`a++`, `a--`).

## 관계 연산자

- 수의 관계를 비교하여 참(true) 또는 거짓(false)을 결과로 얻는 연산자
- 거짓은 0, 참은 1로 사용되지만 0외의 모든 숫자도 참으로 간주된다.

## 비트 연산자

- 비트별(0, 1)로 연산하여 결과를 얻는 연산자
  ![image](https://github.com/JeongwooHam/FE_Study_Logs/assets/123251211/8e431647-e78e-4b9b-bc7c-3896b5e121a2)

## 논리 연산자

- 두 개의 논리 값을 연산하여 참(true) 또는 거짓(false)을 결과로 얻는 연산자
- 관계 연산자와 마찬가지로 거짓은 0, 참은 1이다.

## 대입 연산자

- 연산 후 결과를 대입하는 연산식을 간략하게 입력할 수 있도록 대입 연산자를 제공한다.
- 대입 연산자는 산술, 관계, 비트, 논리 연산자에 모두 적용할 수 있다.
  ![image](https://github.com/JeongwooHam/FE_Study_Logs/assets/123251211/92d85847-bbe2-4fbf-83e0-ac0647eb7d32)

## 조건 연산자

- 조건에 따라 서로 다른 수식을 수행한다.
- 형식: `조건 ? 수식1 : 수식2`

## 연산자 우선 순위

- 한 개의 수식에 여러 개의 연산자가 사용되면 기본적으로 아래 표의 순서대로 처리된다.
- 아래 표의 한 줄에 가로로 나열된 연산자는 우선순위가 같기 때문에 결합규칙에 따라 **←**는 오른쪽에 있는 연산자부터, **_→_**는 왼쪽에 있는 연산자부터 차례로 계산된다.
  ![image](https://github.com/JeongwooHam/FE_Study_Logs/assets/123251211/6d539f27-d010-47bd-a02b-28612b3b7ff5)

# 📍 포인터

## 포인터와 포인터 변수

- **포인터**
  - 변수의 주소
  - C언어에서는 주소를 제어할 수 있는 기능을 제공한다.
- **포인터 변수**
  - C언어에서 변수의 주소를 저장할 때 사용하는 변수
- 포인터 변수를 선언할 때는 자료의 형을 먼저 쓰고 변수명 앞에 간접 연산자 `*`를 붙인다.
  - 예: `int *a;`
- 포인터 변수에 주소를 저장하기 위해 변수의 주소를 알아낼 때는 변수 앞에 번지 연산자 `&`를 붙인다.
  - 예: `a = &b;`
- 실행문에서 포인터 변수에 간접 연산자 `*`를 붙이면 해당 포인터 변수가 가리키는 곳의 값을 말한다
  - 예: `c = *a;`
- 포인터 변수는 필요에 의해 동적으로 할당되는 메모리 영역인 힙 영역에 접근하는 동적 변수이다.

### 예시

![image](https://github.com/JeongwooHam/FE_Study_Logs/assets/123251211/67090dd3-7bc2-4e3c-8fc2-844e62f858c4)

```c
main()
{
  int a = 100;
  int *b; // 해당 변수가 포인터 변수임을 의미한다.
  b = &a; // 변수 a의 주소가 b에 기억된다. b가 변수 a의 주소를 가리키고 있다.
  *b = *b + 100; // b가 가리키는 곳의 값은 a이므로 a의 값도 바뀐다.
  printf("%d, %d", a, *b); // 200, 200
}
```

- a 변수에 100을 저장시키고, a 변수의 주소를 포인터 변수 b에 기억시킨 경우
- a는 메모리의 4번지에 대한 이름이다.
- a 변수의 주소는 4다.
- a 변수에는 100이 기억되어 있다.
- 4번지에는 100이 기억되어 있다.
- `&a`는 a 변수의 주소 ➡️ 즉 `&a`는 4다.
- 포인터 변수 b는 a 변수의 주소를 기억하고 있다.
- 포인터 변수가 **가리키는 곳의 값**을 말할 때는 `*`을 붙인다.
- `*b`는 b에 저장된 주소가 가리키는 곳에 저장된 값을 말하므로 100이다.

## 포인터와 배열

- 배열을 포인터 변수에 저장한 후 포인터를 이용해 배열의 요소에 접근할 수 있다.
- 배열 위치를 나타내는 첨자를 생략하고 배열의 대표명만 지정하면 배열의 첫 번째 요소의 주소를 지정하는 것과 같다.
- 배열 요소에 대한 주소를 지정할 때는 일반 변수와 동일하게 `&` 연산자를 사용한다.

```c
int a[5], *b;
b = a; // 배열의 대표명 ➡️ a 배열의 "시작 주소"인 a[0]의 주소를 b에 저장한다.
b = &a[0]; // a 배열의 "첫 번째 요소인 a[0]의 주소"(&)를 b에 저장한다.
```

- 배열의 요소가 포인터인 포인터형 배열을 선언할 수 있다.

```c
main()
{
  int a[5];
  int i;
  int *p; // 정수형 변수가 저장된 곳의 주소를 기억할 정수형 포인트 변수
  for(i = 0; i < 5; i++)
	  a[i] = i + 10; // 배열에 [10, 11, 12, 13, 14]가 담긴다.
  // 배열명 a는 배열의 주소 ➡️ 포인터 변수 p에는 배열 a의 시작 위치가 기억된다.
  p = a;  // 🚨 p = &a (x) ➡️ 배열의 이름은 주소이다. p = &a[0]처럼 써야 한다.
  for(i = 0; i < 5; i++)
	  print f("%d", *(p+i));
}
```

- p에 저장된 값은 정수형 배열의 시작 주소이다.
- p의 값을 1 증가 시킨다는 것은 현재 p가 가리키고 있는 정수형 자료의 주소에서 다음 정수형 자료의 주소로 가리키는 주소를 증가시킨다는 것이다.
- 정수형 자료의 크기는 4바이트이므로 다음 물리적 메모리의 주소는 **4Byte 증가한 곳**을 가리키는 것이다.
- p에 저장된 배열의 시작주소에서 1번지씩, 즉 4Byte씩 증가시키는 것이다.
  - `p+0` : 배열의 시작 주소에 0을 더했으므로, 배열의 시작 주소인 ‘1000’ 번지 그대로이다. ➡️ `*(p+0)` : ‘1000’ 번지의 값은 10이다. 10을 출력한다.
  - `p+1` : ‘1000’에서 한 번지 증가한 주소는 ‘1004’ 번지이다. ➡️ `(p+1)` : ‘1004’ 번지의 값은 11이다. 11을 출력한다.

# 📍 배열

## 배열의 개요

- 동일한 데이터 유형을 여러 개 사용해야 할 경우 이를 손쉽게 처리하기 위해 여러 개의 변수들을 조합해서 하나의 이름으로 정의해 사용하는 것
- 하나의 이름으로 여러 기억장소를 가리키기 때문에 배열에서 개별적인 요소들의 위치는 첨자를 이용하여 지정한다.
- 배열은 변수명 뒤에 대괄호 `[ ]`를 붙이고 그 안에 사용할 개수를 지정한다.
- C언어에서 배열의 위치는 0부터 시작된다.
- 배열은 행 우선으로 데이터가 기억장소에 할당된다.
- C 언어에서 배열 위치를 나타내는 첨자 없이 배열 이름을 사용하면 배열의 첫 번째 요소의 주소를 지정하는것과 같다.

## 1차원 배열

- 변수들을 일직선상의 개념으로 조합한 배열
- `자료형 변수명[개수];`
  - 자료형 : 배열에 저장할 자료의 형을 지정함
  - 변수명 : 사용할 배열의 이름으로 사용자가 임의로 지정함
  - 개수 : 배열의 크기를 지정하는 것으로 생략할 수 있음
- 예: `int a[5]`
  - `a[3]`: a는 배열의 이름, 3은 첨자로서 배열 a에서의 위치
  - `a[3]`에 4를 저장시키려면 `a[3] = 4`

## 2차원 배열

- 변수들을 평면, 즉 행과 열로 조합한 배열
- `자료형 변수명[행개수][열개수]`
  - 자료형 : 배열에 저장할 자료의 형을 지정함
  - 변수명 : 사용할 배열의 이름으로 사용자가 임의로 지정함
  - 행개수 : 배열의 행 크기를 지정함
  - 열개수 : 배열의 열 크기를 지정함
- 예: `int b[3][3]`
  - 3개의 행과 3개의 열을 갖는 정수형 배열 b
  - `b[0][2]`: b는 배열의 이름, 0은 행 첨자, 2는 열 첨자로서 배열 b에서의 위치를 나타낸다.

## 배열의 초기화

- 배열 선언 시 초기값을 지정할 수 있다.
- 배열을 선언할 때 배열의 크기를 생략하는 경우에는 반드시 초기값을 지정해야 초기값을 지정한 개수 만큼의 배열이 선언된다.

### 1차원 배열 초기화

```c
char a[3] = {'A', 'B', 'C'}
char a[ ] = {'A', 'B', 'C'}
```

### 2차원 배열 초기화

```c
int a[2][4] = { {10, 20, 30, 40}, {50, 60, 70, 80} };
int a[2][4] = {10, 20, 30, 40, 50, 60, 70, 80}
```

### 배열의 개수보다 적은 수로 배열을 초기화할 경우

- 입력된 값만큼 지정한 숫자가 입력되고, 나머지 요소에는 0이 입력된다.

```c
int a[5] = { 3, }; 또는 int a[5] = { 3 }; // {3, 0, 0, 0, 0}
```

## 배열 형태의 문자열 변수

- C언어에서는 큰따옴표(“ ”)로 묶인 글자는 글자 수에 관계 없이 문자열로 처리된다.
- C언어에는 문자열을 저장하는 자료형이 없기 때문에 배열, 또는 포인터를 이용하여 처리한다.
- `char 배열이름[크기] = “문자열”`
- 배열에 문자열을 저장하면 문자열의 끝을 알리기 위한 널 문자(‘\0’)가 문자열 끝에 자동으로 삽입된다.
- 배열에 문자열을 저장할 때는 배열 선언 시 초기값으로 지정해야 하며, 이미 선언된 배열에는 문자열을 저장할 수 없다.
- 문자열 끝에 자동으로 널 문자(‘\0’)가 삽입되므로, 널 문자까지 고려하여 배열 크기를 지정해야 한다.
  - 예: `char a[5] = "love"` ➡️ `{"l", "o", "v", "e", \0}`

# 🌟 Java

## Java의 데이터 타입 크기 및 기억 범위

![image](https://github.com/JeongwooHam/FE_Study_Logs/assets/123251211/703f918c-a688-42d4-aacc-5bef316c131a)

## Java에서의 표준 출력

- JAVA에서 값을 화면에 출력할 때는 System 클래스의 서브 클래스인 out 클래스의 메소드 `print( )`, `println( )`, `printf( )` 등을 사용하여 출력한다.

### 형식 1

- 서식 문자열에 맞게 변수의 내용을 출력함
  > `System.out.printf(서식 문자열, 변수)`
- `printf( )`메소드는 C언어의 `printf( )` 함수와 사용법이 동일하다.
- 예: `System.out.printf(“%-8.2f”, 200.2);` ➡️ `200.20VV`
- `%` : 서식 문자임을 지정
- `-` : 왼쪽부터 출력
- `8` : 출력 자릿수를 8자리로 지정
- `2` : 소수점 이하를 2자리로 지정
- `f` : 실수로 출력

### 형식 2

- 값이나 변수의 내용을 형식없이 출력함
  > `System.out.print( )`
- 문자열을 출력할 때는 **큰따옴표**로 묶어줘야 한다.
- 문자열 또는 문자열 변수를 연속으로 출력할 때는 `+`를 이용한다.
- 예: `System.out.print(“abc123” + “def”);` ➡️ `abc123def`

### 형식 3

- 값이나 변수의 내용을 형식 없이 출력한 후 커서를 다음 줄의 처음으로 이동함
  > `System.out.println( )`
- 출력 후 다음 줄로 이동한다는 것을 제외하면 `print( )` 메소드와 사용법이 동일하다.
- 예: System.out.print(“abc123” + “def”);
  ```java
  abc123def
  | // 커서의 위치
  ```

# 🌟 조건문, 반복문

## switch문

- 조건에 따라 분기할 곳이 여러 곳인 경우 간단하게 처리할 수 있는 제어문
- case문의 레이블에는 한 개의 상수만 지정할 수 있으며, int, char, enum형의 상수만 가능하다.
- case문의 레이블에는 변수를 지정할 수 없다.
- break문은 생략이 가능하지만 break문이 생략되면 수식과 레이블이 일치할 때 실행할 문장부터 break문 또는 switch문이 종료될 때까지 모든 문장이 실행된다

## for문

- 처음부터 최종값에 대한 조건식을 만족하지 못하면 한 번도 수행하지 않는다.

## while문

- 조건이 참인동안 실행할 문장을 반복 수행하다가 조건이 거짓이면 while문을 끝낸 후 다음 코드를 실행한다.
- while문은 조건이 처음부터 거짓이면 한 번도 수행하지 않는다.

## do~while문

- 조건이 참인 동안 정해진 문장을 반복 수행하다가 조건이 거짓이면 반복문을 벗어나는 while문과 같은 동작을 한다.
- 다만 **do~while문**은 실행할 문장을 **무조건 한 번 실행**한 다음 조건을 판단하여 탈출 여부를 결정한다.
- do~while문은 실행할 문장을 우선 실행한 후 조건을 판별하여 조건이 참이면 실행할 문장을 계속 반복 수행하고, 거짓이면 do~while문을 끝낸 후 다음 코드를 실행한다.

## break, continue

- 반복문의 실행을 제어하기 위해 사용되는 예약어

### break

- switch문이나 반복문 안에서 break가 나오면 블록을 벗어난다.

### continue

- continue 이후의 문장을 실행하지 않고 제어를 반복문의 처음으로 옮긴다.
- 반복문에서만 사용된다.

# 🌟 Python

## Python의 Sequence 자료형

- 리스트(List), 튜플(Tuple), range, 문자열처럼 값이 연속적으로 이어진 자료형

### 리스트(List)

- 다양한 자료형의 값을 연속적으로 저장한다.
- 필요에 따라 개수를 늘리거나 줄일 수 있다.

### 튜플(Tuple)

- 리스트처럼 요소를 연속적으로 저장한다.
- 요소의 추가, 삭제, 변경은 불가능하다.

### range

- 연속된 숫자를 생성하는 것
- 리스트, 반복문 등에서 많이 사용됨

## Python의 기본 문법

- 변수의 자료형에 대한 선언이 없다.
- 문장의 끝을 의미하는 세미콜론(;)을 사용할 필요가 없다.
- 변수에 연속하여 값을 저장하는 것이 가능하다.
  - 예: `x, y, z = 10, 20, 30`
- if나 for와 같이 코드 블록을 포함하는 명령문을 작성할 때 코드 블록은 콜론(:)과 여백으로 구분한다.
  - 여백은 일반적으로 **4칸** 또는 **한 개의 탭**만큼 띄워야한다.
  - 같은 수준의 코드들은 반드시 동일한 여백을 가져야 한다.

## Python의 데이터 입/출력 함수

### `print()`

- `print(출력값1, 출력값2, …, sep = 분리문자, end = 종료문자)`
  - **출력값**에는 숫자, 문자, 문자열, 변수 등 다양한 값이나 식이 올 수 있다.
  - **sep**
    - 여러 값을 출력할 때 값과 값 사이를 구분하기 위해 출력하는 문자
    - 생략할 경우 기본값은 공백 한 칸(`‘ ’`)이다.
  - **end**
    - 맨 마지막에 표시할 문자
    - 생략할 경우 기본값은 줄 나눔이다.
- 예: `print(82, 24, sep = '-', end = ',' )` ➡️ `82-24,`
- 자동으로 개행된다.

### `input()`

- Python의 표준 입력 함수
- 키보드로 입력 받아 변수에 저장하는 함수
- `변수 = input(출력문자)`
  - **출력문자**는 생략이 가능하다.
  - **변수**는 사용자가 임의로 지정할 수 있다.
  - 값을 입력하고 `J`를 누르면 입력한 값이 변수에 저장된다.

### 입력 값의 형 변환 (Casting)

- `input( )` 함수는 입력되는 값을 무조건 문자열로 저장하므로, 숫자로 사용하기 위해서는 형을 변환해야 한다.

> **변환할 데이터가 1개일 때**

- 정수로 변환 시: `변수 = int(input( ))`
- 실수로 변환 시: `변수 = float(input( ))`

> **변환할 데이터가 2개 이상일 때**

- `변수1, 변수2, ... = map*(int, input().split())`

## if문

```python
if 조건:
	조건이 참일 경우 실행할 문장
elif 조건:
	실행할 문장
else:
	실행할 문
```

## for문

### 형식 1

- 0에서 최종값 -1까지 연속된 숫자를 순서대로 변수에 저장하며 실행할 문장을 반복 수행한다.
  - `range(10)`: 0에서 9까지
  - `range(11, 20)`: 11에서 19까지
  - `range(-10, 20, 2)`: -10에서 19까지 2씩 증가하면서

```python
for 변수 in range(최종값):
	실행할 문장
```

### 형식 2

- 리스트의 0번째 요소에서 마지막 요소까지 순서대로 변수에 저장하며 실행할 문장을 반복 수행한다.

```python
for 변수 in 리스트
	실행할 문장
```

## while문

- `while`: 예약어
- 참이나 거짓을 결과로 갖는 수식을 조건에 입력한거나 참/거짓을 직접 입력할 수도 있다.

```python
while 조건:
	실행할 문장
```

## 클래스

- `class`: 예약어, 클래스명은 사용자가 임의로 저장한다.
- `def`
  - 메소드를 정의하는 예약어
  - 그대로 입력하고 메소드명은 사용자가 임의로 지정한다.
- `self`
  - 메소드에서 자기 클래스에 속한 변수에 접근할 때 사용하는 명칭
  - 일반적으로 `self`를 사용하나 사용자가 임의로 지정해도 된다.
  - `x, y = 10, 20`인 경우 `self.x`, `self.y`로 접근하여 사용할 수 있다.
- `인수`
  - 메소드를 호출하는 곳에서 보낸 값을 저장할 변수
  - 사용자가 임의로 지정한다.
- `return`
  - 메소드를 호출할 위치로 값을 돌려주기 위해 사용하는 예약어
  - 없을 경우 생략할 수 있다.
  - `값`: 변수, 객체, 계산식 등이 올 수 있다.

```python
class 클래스명:
	실행할 문장
	def 메소드명(self, 인수):
		실행할 문장
		return 값
```

> **객체의 선언 형식**

- `변수명 = 클래스명( )`

## 클래스 없는 메소드의 사용

- C언어의 사용자 정의 함수와 같이 클래스 없이 메소드만 단독으로 사용할 수 있다.

```python
def calc(x, y):
	x *= 3 # 3 * 3
	y /= 3 # 12 / 3
	print(x, y) # 9 4.0
	return x # x의 값 9를 a에 저장한 뒤 제어를 마지막 줄로 옮긴다.

a, b = 3, 12
a = calc(a, b)

print(a, b)
# 9 4.0
# 9 12
```

## 리스트 (List)

- C와 Java에서는 여러 요소들을 하나의 이름으로 처리할 때 배열을 사용했는데 Python에서는 리스트를 사용한다.
- 리스트는 필요에 따라 개수를 늘이거나 줄일 수 있기 때문에 리스트를 선언할 때 **크기를 적지 않는다**.
- 배열과 달리 하나의 리스트에 정수, 실수, 문자열 등 **다양한 자료형**을 섞어서 저장할 수 있다.
- Python에서 리스트의 위치는 0부터 시작한다.

> **형태**

- `리스트명 = [값1, 값2, ...]`
- `리스트명 = list([값1, 값2, ...])`

## 딕셔너리 (Dictionary)

- 연관된 값을 묶어서 저장하는 용도로 사용한다.
- **리스트**는 저장된 요소에 접근하기 위한 키로 위치에 해당하는 숫자를 사용한다.
- **딕셔너리**는 사용자가 원하는 값을 키로 지정해 사용한다.
- 딕셔너리에 접근할 때는 딕셔너리 뒤에 대괄호(`[ ]`)를 사용하며, 대괄호(`[ ]`) 안에 키를 지정한다.

> **형태**

- `딕셔너리명 = {키1: 값1, 키2: 값2, ...}`
- `딕셔너리명 = dict({키1: 값1, 키2: 값2, ...})`

## 슬라이스 (Slice)

- 문자열이나 리스트와 같은 순차형 객체에서 일부를 잘라(slicing) 반환하는 기능

> **형태**

- `객체명[초기위치:최종위치]`
  - **초기위치**에서 **최종위치-1**까지의 요소들을 가져온다.
- `객체명[초기위치:최종위치:증가값]`
  - **초기위치**에서 **최종위치-1**까지 **증가값**만큼 증가하면서 해당 위치의 요소들을 가져온다.
  - **증가값**이 음수인 경우 **초기위치**에서 **최종위치+1**까지 **증가값** 만큼 감소하면서 해당 위치의 요소들을 가져온다.

### 일부 인수를 생략하고 사용하기

> **`a = ['a', 'b', 'c', 'd', 'e']`일 때**

- 객체의 모든 요소를 반환한다.
  - `객체명[:]`, `객체명[::]`
  - `['a', 'b', 'c', 'd', 'e']`
- 객체의 ‘초기위치’에서 마지막 위치까지의 요소들을 반환한다.
  - `객체명[초기위치:]`
  - `a[3:]` ➡️ `['d', 'e']`
- 객체의 0번째 위치에서 ‘최종위치’-1까지의 요소들을 반환한다.
  - `객체명[:최종위치]`
  - `a[:3]` ➡️ `['a', 'b', 'c']`
- 객체의 0번째 위치에서 마지막 위치까지 ‘증가값’만큼 증가하면서 해당 위치의 요소들을 반환한다.
  - `객체명[::증가값]`
  - `a[::3]` ➡️ `['a', 'd']`

# 🌟 절차적 프로그래밍 언어

## C

- 1972년 미국 벨 연구소의 데니스 리치에 의해 개발됨
- 시스템 소프트웨어를 개발하기 편리하여 시스템 프로그래밍 언어로 널리 사용됨
- 자료의 주소를 조작할 수 있는 포인터를 제공함
- 고급 프로그래밍 언어이면서 저급 프로그램 언어의 특징을 모두 갖춤
- UNIX의 일부가 C 언어로 구현됨
- **컴파일러** 방식의 언어
- 이식성이 좋아 컴퓨터 기종에 관계없이 프로그램을 작성할 수 있음

## ALGOL

- 수치 계산이나 논리 연산을 위한 과학 기술 계산용 언어
- PASCAL과 C 언어의 모체가 됨

## COBOL

- 사무 처리용 언어
- 영어 문장 형식으로 구성되어 있어 이해와 사용이 쉬움
- 4개의 DIVISION으로 구성되어 있음

## FORTRAN

- 과학 기술 계산용 언어임
- 수학과 공학 분야의 공식이나 수식과 같은 형태로 프로그래밍 할 수 있음

# 🌟 객체 지향 프로그래밍 언어

## JAVA

- **분산 네트워크** 환경에 적용이 가능하며, **멀티스레드** 기능을 제공하므로 여러 작업을 동시에 처리할 수 있음
- 운영체제 및 하드웨어에 독립적이며, 이식성이 강함
- 캡슐화가 가능하고 재사용성 높음

## C++

- C 언어에 객체지향 개념을 적용한 언어
- 모든 문제를 객체로 모델링하여 표현함

## Smalltalk

- 1세대 객체지향 프로그래밍 언어 중 하나로 순수한 객체지향 프로그래밍 언어
- 최초로 **GUI**를 제공한 언어

# 🌟 스크립트 언어

## JavaScript

- 웹 페이지의 동작을 제어하는 데 사용되는 클라이언트용 스크립트 언어
- 클래스가 존재하지 않으며 변수 선언도 필요 없음
- 서버에서 데이터를 전송할 때 아이디, 비밀번호, 수량 등의 입력 사항을 확인하기 위한 용도로 많이 사용됨

## VBScript

- Visual Basic Script
- 마이크로소프트 사에서 자바 스크립트에 대응하기 위해 제작한 언어
- Active X를 사용하여 마이크로소프트 사의 애플리케이션들을 컨트롤할 수 있음

## ASP

- Active Server Page
- 서버 측에서 동적으로 수행되는 페이지를 만들기 위한 언어로 마이크로소프트 사에서 제작함
- Windows 계열에서만 수행 가능한 프로그래밍 언어

## JSP

- Java Server Page
- JAVA로 만들어진 서버용 스크립트
- 다양한 운영체제에서 사용이 가능함

## PHP

- Professional Hypertext Preprocessor
- 서버용 스크립트 언어
- Linux, Unix, Windows 운영체제에서 사용 가능함
- C, Java 등과 문법이 유사하므로 배우기 쉬워 웹 페이지 제작에 많이 사용됨

## Python

- 객체지향 기능을 지원하는 대화형 인터프리터 언어
- 플랫폼에 독립적이고 문법이 간단하여 배우기 쉬움

## ShellScript

- 유닉스/리눅스 계열의 쉘(Shell)에서 사용되는 명령어들의 조합으로 구성된 스크립트 언어
- 컴파일 단계가 없어 실행 속도가 빠름
- 저장 시 확장자로 `.sh`가 붙음

> **쉘의 종류**

- Bash Shell
- Bourne Shell
- C Shell
- Korn Shell

> **쉘 스크립트에서 사용되는 제어문**

- 선택형 : if, case
- 반복형 : for, while, until

## Basic

- 절차 지향 기능을 지원하는 대화형 인터프리터 언어
- 초보자도 쉽게 사용할 수 있는 문법 구조를 가짐

# 🌟 선언형 프로그래밍 언어

## HTML

- 인터넷의 표준 문서인 하이퍼텍스트 문서를 만들기 위해 사용하는 언어
- 특별한 데이터 타입이 없는 단순한 텍스트이므로 호환성이 좋고 사용이 편리함

## LISP

- 인공지능 분야에 사용되는 언어
- 기본 자료 구조: 연결 리스트 구조
- 재귀(Recursion) 호출을 많이 사용함

## PROLOG

- 논리학을 기초로 한 고급 언어
- 인공 지능 분야에서의 논리적인 추론이나 리스트 처리 등에 주로 사용됨

## XML

- 기존 HTML의 단점을 보완하여 웹에서 구조화된 폭넓고 다양한 문서들을 상호 교환할 수 있도록 설계된 언어
- HTML에 사용자가 새로운 태그(Tag)를 정의할 수 있으며, 문서의 내용과 이를 표현하는 방식이 독립적임

## Haskell

- 함수형 프로그래밍 언어
- 부작용(Side Effect)이 없음
- 코드가 간결하고 에러 발생 가능성이 낮음

# 🌟 라이브러리

- 프로그램을 효율적으로 개발할 수 있도록 자주 사용하는 함수나 데이터들을 미리 만들어 모아 놓은 집합체
- 자주 사용하는 함수들의 반복적인 코드 작성을 피하기 위해 미리 만들어 놓은 것
- 필요할 때는 언제든지 호출하여 사용할 수 있다.

## 라이브러리의 종류

> **표준 라이브러리**

- 프로그래밍 언어에 기본적으로 포함되어 있는 라이브러리
- 여러 종류의 모듈이나 패키지 형태

> **외부 라이브러리**

- 개발자들이 필요한 기능들을 만들어 인터넷 등에 공유해 놓은 것
- 외부 라이브러리를 다운 받아 설치한 후 사용함

## C언어의 대표적인 표준 라이브러리

- C언어는 라이브러리를 헤더 파일로 제공하는데, 각 헤더 파일에는 응용 프로그램 개발에 필요한 함수들이 정리되어 있다.
- C언어에서 헤더 파일을 사용하려면 `#include <stdio.h>`와 같이 include문을 이용해 선언한 후 사용해야 한다.

### 표준 라이브러리의 종류

> **`studio.h`**

- 데이터의 입·출력에 사용되는 기능들을 제공함
- 주요 함수 : printf, scanf, fprintf, fscanf, fclose, fopen 등

> **`math.h`**

- 수학 함수들을 제공함
- 주요 함수 : sqrt, pow, abs 등

> **`string.h`**

- 문자열 처리에 사용되는 기능들을 제공함
- 주요 함수 : strlen, strcpy, strcmp 등

> **`stdlib.h`**

- 자료형 변환, 난수 발생, 메모리 할당에 사용되는 기능들을 제공함
- 주요 함수 : atoi, atof, srand, rand, malloc, free 등

> **`time.h`**

- 시간 처리에 사용되는 기능들을 제공함
- 주요 함수 : time, clock 등

# 🌟 예외 처리

- **_예외(Exception)_**
  - 프로그램의 정상적인 실행을 방해하는 조건이나 상태
- **_예외 처리(Exception Handling)_**
  - 예외가 발생했을 때 프로그래머가 해당 문제에 대비해 작성해 놓은 처리 루틴을 수행하도록 하는 것
- 예외가 발생했을 때 일반적인 처리 루틴은 프로그램을 종료시키거나 로그를 남기도록 하는 것
- C++, Ada, JAVA, 자바스크립트와 같은 언어에는 예외 처리 기능이 내장되어 있다.
- 그 외의 언어에서는 필요한 경우 조건문을 이용해 예외 처리 루틴을 작성한다.
- 예외의 원인
  - 컴퓨터 하드웨어 문제
  - 운영체제의 설정 실수
  - 라이브러리 손상
  - 사용자의 입력 실수
  - 받아들일 수 없는 연산
  - 할당하지 못하는 기억장치 접근 등

# 🌟 운영 체제

## 운영 체제의 개요

- 컴퓨터 시스템의 자원들을 효율적으로 관리하며, 사용자가 컴퓨터를 편리하고 효과적으로 사용할 수 있도록 환경을 제공하는 여러 프로그램의 모임
- 컴퓨터 사용자와 컴퓨터 하드웨어 간의 인터페이스로서 동작하는 시스템 소프트웨어의 일종으로, 다른 응용 프로그램이 유용한 작업을 할 수 있도록 환경을 제공해준다.

> **운영체제의 목적**

- 처리 능력 향상,
- 사용 가능도 향상
- 신뢰도 향상
- 반환 시간 단축

### 운영 체제의 성능을 평가하는 기준

> **처리 능력 (Throughput)**

- 일정 시간 내에 시스템이 처리하는 일의 양

> **반환 시간 (Turn Around Time)**

- 시스템에 작업을 의뢰한 시간부터 처리가 완료될 때까지 걸린 시간

> **사용 가능도 (Availability)**

- 시스템을 사용할 필요가 있을 때 즉시 사용 가능한 정도

> **신뢰도 (Reliability)**

- 시스템이 주어진 문제를 정확하게 해결하는 정도

## 운영 체제의 구성

### 제어 프로그램 (Control)

- 컴퓨터 전체의 작동 상태 감시, 작업의 순서 지정, 작업에 사용되는 데이터 관리 등의 역할을 수행하는 것

> **감시 프로그램 (Supervisor Program)**

- 제어 프로그램 중 가장 핵심적인 역할을 하는 것
- 자원의 할당 및 시스템 전체의 작동 상태를 감시하는 프로그램

> **작업 관리 프로그램 (Job Management Program)**

- 작업이 정상적으로 처리될 수 있도록 작업의 순서와 방법을 관리하는 프로그램

> **데이터 관리 프로그램 (Data Management Program)**

- 작업에 사용되는 데이터와 파일의 표준적인 처리 및 전송을 관리하는 프로그램

### 처리 프로그램 (Processing)

- 제어 프로그램의 지시를 받아 사용자가 요구한 문제를 해결하기 위한 프로그램

> **언어 번역 프로그램**

- 사용자가 고급언어로 작성한 원시 프로그램을 기계어 형태의 목적 프로그램으로 변환시키는 것
- 컴파일러, 어셈블러, 인터프리터 등이 있음

> **서비스 프로그램**

- 사용자가 컴퓨터를 더욱 효율적으로 사용할 수 있도록 제작된 프로그램
- 분류/병합(Sort/Merge), 유틸리티 프로그램

## 운영 체제의 기능

- 프로세서(처리기, Processor), 기억장치(주기억장치, 보조기억장치), 입·출력장치, 파일 및 정보 등의 자원을 관리한다.
- 자원을 효율적으로 관리하기 위해 자원의 스케줄링 기능을 제공한다.
- 사용자와 시스템 간의 편리한 인터페이스를 제공한다.
- 시스템의 각종 하드웨어와 네트워크를 관리·제어한다.
- 데이터를 관리하고, 데이터 및 자원의 공유 기능을 제공한다.
- 시스템의 오류를 검사하고 복구한다.
- 자원 보호 기능을 제공한다.
- 입·출력에 대한 보조 기능을 제공한다.
- 가상 계산기 기능을 제공한다

## File Descriptor

- = 파일 제어블록(FCB; File Control Block)
- 파일을 관리하기 위한 시스템(운영체제)이 필요로 하는 파일에 대한 정보를 가진 제어 블록
- 파일마다 독립적으로 존재하며, 시스템에 따라 다른 구조를 가질 수 있다.
- 보통 파일 디스크립터는 보조기억장치 내에 저장되어 있다가 해당 파일이 Open될 때 주기억장치로 옮겨진다.
- 파일 시스템이 관리하므로 사용자가 직접 참조할 수 없다.

# 📍 Windows

- 1990년대 마이크로소프트(Microsoft) 사가 개발한 운영체제

## Windows의 주요 특징

### GUI

- 그래픽 사용자 인터페이스
- 키보드로 명령어를 직접 입력하지 않고, 마우스로 아이콘이나 메뉴를 선택하여 모든 작업을 수행하는 방식

### Preemptive Multi-Tasking

- 선점형 멀티태스킹
- 동시에 여러 개의 프로그램을 실행하는 멀티태스킹을 하면서 운영체제가 각 작업의 CPU 이용 시간을 제어하여 응용 프로그램 실행중 문제가 발생하면 해당 프로그램을 강제 종료시키고 모든 시스템 자원을 반환하는 방식

### PnP

- 자동 감지 기능; Plug and Play
- 컴퓨터 시스템에 프린터나 사운드 카드 등의 하드웨어를 설치했을 때, 해당 하드웨어를 사용하는 데 필요한 시스템 환경을 운영체제가 자동으로 구성해 주는 기능

### OLE

- Object Linking and Embedding
- 다른 여러 응용 프로그램에서 작성된 문자나 그림 등의 개체(Object)를 현재 작성 중인 문서에 자유롭게 연결(Linking)하거나 삽입(Embedding)하여 편집할 수 있게 하는 기능

### 255자의 긴 파일명

- 파일 이름을 지정할 때 **_VFAT_**(Virtual File Allocation Table)를 이용하여 최대 **255자**까지 지정할 수 있음
- 파일 이름으로는` \ / : * ? “ < > |`를 제외한 모든 문자 및 공백을 사용할 수 있다.
- 한글의 경우 **127자**까지 지정할 수 있음

### Single-User 시스템

- 컴퓨터 한 대를 한 사람만이 독점해서 사용함

# 📍UNIX

## UNIX의 개요 및 특징

- 1960년대 AT&T 벨(Bell) 연구소, MIT, General Electric이 공동 개발한 운영체제
- **시분할 시스템**(Time Sharing System)을 위해 설계된 대화식 운영체제
- 소스가 공개된 개방형 시스템(Open System)
- 대부분 C 언어로 작성되어 있어 이식성이 높으며 장치, 프로세스 간의 호환성이 높다.
- 크기가 작고 이해하기가 쉽다.
- 많은 네트워킹 기능을 제공하므로 통신망(Network) 관리용 운영체제로 적합하다.
- 트리 구조의 파일 시스템을 갖는다.
- 전문적인 프로그램 개발에 용이하다.
- 다양한 유틸리티 프로그램들이 존재한다.
- 다중 사용자(Multi-User), 다중 작업(Multi-Tasking)을 **모두** 지원한다.

### 다중 사용자, 다중 작업

- 다중 사용자(Multi-User): 여러 사용자가 동시에 시스템을 사용하는 것
- 다중 작업(Multi-Tasking): 여러 개의 작업이나 프로그램을 동시에 수행하는 것
- 하나 이상의 작업을 백그라운드에서 수행하므로 여러 작업을 동시에 처리할 수 있다.

## UNIX 시스템의 구성

### 커널(Kernel)

- UNIX의 가장 핵심적인 부분이다.
- 컴퓨터가 부팅될 때 **주기억장치에 적재된 후 상주하면서** 실행된다.
- 하드웨어를 보호하고, 프로그램과 하드웨어 간의 인터페이스 역할을 담당한다.
- 프로세스(CPU 스케줄링) 관리, 기억장치 관리, 파일 관리, 입·출력 관리, 프로세스간 통신, 데이터 전송 및 변환 등 여러 가지 기능을 수행한다.
- 프로세스와 메모리를 관리한다.

### 쉘(Shell)

- 사용자의 명령어를 인식하여 프로그램을 호출하고 명령을 수행하는 명령어 해석기이다.
- 시스템과 사용자 간의 인터페이스를 담당한다.
- DOS의 COMMAND.COM과 같은 기능을 수행한다.
- **주기억장치에 상주하지 않고**, 명령어가 포함된 파일 형태로 존재하며 보조 기억장치에서 교체 처리가 가능하다.
- 파이프라인 기능을 지원한다.
- 입·출력 재지정을 통해 출력과 입력의 방향을 변경할 수 있다.
- 공용 Shell(Bourne Shell, C Shell, Korn Shell)이나 사용자 자신이 만든 Shell을 사용할 수 있다.
- 사용자 명령을 해석하고 커널로 전달한다.
- 반복적인 명령 프로그램을 만드는 프로그래밍 기능을 제공한다.
- 초기화 파일을 이용해 사용자 환경을 설정하는 기능을 제공한다. ㄹ

### Utility Program

- 일반 사용자가 작성한 응용 프로그램을 처리하는 데 사용한다.
- DOS에서의 외부 명령어에 해당된다.
- 에디터, 컴파일러, 인터프리터, 디버거 등

## UNIX / LINUX의 주요 환경 변수

## UNIX / LINUX 기본 명령어

# 🌟 기억 장치

## 기억 장치 관리 - 배치 전략

- 새로 반입되는 프로그램이나 데이터를 주기억장치의 어디에 위치시킬 것인지를 결정하는 전략

### 배치 전략의 구분

> **최초 적합 (First Fit)**

- 프로그램이나 데이터가 들어갈 수 있는 크기의 빈 영역 중에서 **첫 번째** 분할 영역에 배치시키는 방법

> **최적 적합 (Best Fit)**

- 프로그램이나 데이터가 들어갈 수 있는 크기의 빈 영역 중에서 **단편화를 가장 작게 남기는** 분할 영역에 배치시키는 방법

> **최악 적합 (Worst Fit)**

- 프로그램이나 데이터가 들어갈 수 있는 크기의 빈 영역 중에서 **단편화를 가장 많이 남기는** 분할 영역에 배치시키는 방법

## Paging 기법

- 가상기억장치에 보관되어 있는 프로그램과 주기억장치의 영역을 **동일한 크기**로 나눈 후 나눠진 프로그램(페이지)을 동일하게 나눠진 주기억장치의 영역(페이지 프레임)에 적재시켜 실행하는 기법
- **_페이지(Page)_**
  - 프로그램을 일정한 크기로 나눈 단위
- **_페이지 프레임(Page Frame)_**
  - 페이지 크기로 일정하게 나누어진 주기억장치의 단위
- 외부 단편화는 발생하지 않으나 **내부 단편화**는 발생할 수 있다.
- 주소 변환을 위해서 페이지의 위치 정보를 가지고 있는 **페이지 맵 테이블**(Page Map Table)이 필요하다.

## Segmentation 기법

- 가상기억장치에 보관되어 있는 프로그램을 **다양한 크기의 논리적인 단위**로 나눈 후 주기억장치에 적재시켜 실행시키는 기법
- **_세그먼트(Segment)_**
  - 프로그램을 배열이나 함수 등과 같은 논리적인 크기로 나눈 단위
  - 각 세그먼트는 고유한 이름과 크기를 갖는다.
- 주소 변환을 위해서 세그먼트가 존재하는 위치 정보를 가지고 있는 **세그먼트 맵 테이블**(Segment Map Table)이 필요하다.
- 내부 단편화는 발생하지 않으나 **외부 단편화**는 발생할 수 있다.

## 페이지 교체 알고리즘

- 페이지 부재(Page Fault)가 발생했을 때 가상기억장치의 필요한 페이지를 주기억장치에 적재해야 하는데, 이때 주기억장치의 모든 페이지 프레임이 사용중이면 어떤 페이지 프레임을 선택하여 교체할 것인지를 결정하는 기법

### OPT

- 최적 교체; OPTimal replacement
- 앞으로 가장 오랫동안 사용하지 않을 페이지를 교체하는 기법
- 벨레이디(Belady)가 제안한 것
- 페이지 부재 횟수가 가장 적게 발생하는 가장 효율적인 알고리즘

### FIFO

- 각 페이지가 주기억장치에 적재될 때마다 그때의 시간을 기억시켜 가장 먼저 들어와서 가장 오래 있었던 페이지를 교체하는 기법
- 이해하기 쉽고, 프로그래밍 및 설계가 간단함

### LRU

- Least Recently Used
- 최근에 가장 오랫동안 사용하지 않은 페이지를 교체하는 기법
- 각 페이지마다 **계수기**(Counter)나 **스택**(Stack)을 두어 현 시점에서 가장 오랫동안 사용하지 않은, 즉 가장 오래 전에 사용된 페이지를 교체함

### LFU

- Least Frequently Used
- 사용 빈도가 가장 적은 페이지를 교체하는 기법
- 활발하게 사용되는 페이지는 사용 횟수가 많아 교체되지 않고 사용됨

### SCR

- 2차 기회 교체; Second Chance Replacement
- 가장 오랫동안 주기억장치에 있던 페이지 중 자주 사용되는 페이지의 교체를 방지하기 위한 것
- FIFO 기법의 단점을 보완하는 기법

### NUR

- Not Used Recently
- LRU와 비슷한 알고리즘으로, 최근에 사용하지 않은 페이지를 교체하는 기법
- 최근에 사용되지 않은 페이지는 향후에도 사용되지 않을 가능성이 높다는 것을 전제로, LRU에서 나타나는 시간적인 오버헤드를 줄일 수 있음
- 최근의 사용 여부를 확인하기 위해서 각 페이지마다 두 개의 비트, 즉 **참조 비트**(Reference Bit)와 **변형 비트**(Modified Bit, Dirty Bit)가 사용됨

## 페이지 크기

### 페이지 크기가 작을 경우

- 페이지 단편화가 감소되고, 한 개의 페이지를 주기억장치로 이동하는 시간이 줄어든다.
- 불필요한 내용이 주기억장치에 적재될 확률이 적으므로 효율적인 워킹 셋을 유지할 수 있다.
- Locality에 더 일치할 수 있기 때문에 기억장치 효율이 높아진다.
- 페이지 정보를 갖는 페이지 맵 테이블의 크기가 커지고, 매핑 속도가 늦어진다.
- 디스크 접근 횟수가 많아져서 전체적인 입·출력 시간은 늘어난다.

### 페이지 크기가 클 경우

- 페이지 정보를 갖는 페이지 맵 테이블의 크기가 작아지고, 매핑 속도가 빨라진다.
- 디스크 접근 횟수가 줄어들어 전체적인 입·출력의 효율성이 증가된다.
- 페이지 단편화가 증가되고, 한 개의 페이지를 주기억장치로 이동하는 시간이 늘어난다.
- 프로세스(프로그램) 수행에 불필요한 내용까지도 주기억장치에 적재될 수 있다.

## Locality

- 국부성, 지역성, 구역성, 국소성
- 프로세스가 실행되는 동안 주기억장치를 참조할 때 **일부 페이지만 집중적으로 참조하는 성질이 있다**는 이론
- 스래싱을 방지하기 위한 워킹 셋 이론의 기반이 되었다.

### 시간 구역성(Temporal Locality)

- 시간 구역성은 프로세스가 실행되면서 하나의 페이지를 **일정 시간 동안** 집중적으로 액세스하는 현상
- 한 번 참조한 페이지는 **가까운 시간 내**에 계속 참조할 가능성이 높음

> **시간 구역성이 이루어지는 기억 장소**

- Loop (반복, 순환)
- 스택 (Stack)
- 부 프로그램 (Sub Routine)
- Counting (1씩 증감)
- 집계(Totaling)에 사용되는 변수(기억장소)

### 공간 구역성(Spatial Locality)

- 공간 구역성은 프로세스 실행 시 **일정 위치**의 페이지를 집중적으로 액세스하는 현상
- 어느 하나의 페이지를 참조하면 **그 근처**의 페이지를 계속 참조할 가능성이 높음

> **공간 구역성이 이루어지는 기억 장소**

- 배열 순회(Array Traversal, 배열 순례)
- 순차적 코드의 실행
- 프로그래머들이 관련된 변수(데이터를 저장할 기억장소)들을 서로 근처에 선언하여 할당되는 기억장소
- 같은 영역에 있는 변수를 참조할 때 사용

## 스래싱 (Thrashing)

- 프로세스의 처리 시간보다 페이지 교체에 소요되는 시간이 더 많아지는 현상
- 다중 프로그래밍 시스템이나 가상기억장치를 사용하는 시스템에서 하나의 프로세스 수행 과정 중 자주 페이지 부재가 발생함으로써 나타나는 현상
- 전체 시스템의 성능이 저하된다.
- 다중 프로그래밍의 정도가 높아짐에 따라 CPU의 이용률은 어느 특정 시점까지는 높아지지만, 다중 프로그래밍의 정도가 더욱 커지면 스래싱이 나타나고, CPU의 이용률은 급격히 감소하게 된다.

### 스래싱 현상 방지 방법

- 다중 프로그래밍의 정도를 적정 수준으로 유지한다.
- 페이지 부재 빈도(Page Fault Frequency)를 조절하여 사용한다.
- 워킹 셋을 유지한다.
- 부족한 자원을 증설하고, 일부 프로세스를 중단시킨다.
- CPU 성능에 대한 자료의 지속적 관리 및 분석으로 임계치를 예상하여 운영한다.

## 워킹 셋 (Working Set)

- 프로세스가 **일정 시간 동안 자주 참조하는** 페이지들의 집합
- 데닝(Denning)이 제안한 프로그램의 움직임에 대한 모델
- 프로그램의 Locality 특징을 이용한다.
- 자주 참조되는 워킹 셋을 주기억장치에 상주시킴으로써 페이지 부재 및 페이지 교체 현상이 줄어들어 프로세스의 기억장치 사용이 안정된다.
- 시간이 지남에 따라 자주 참조하는 페이지들의 집합이 변화하기 때문에 워킹 셋은 시간에 따라 변경된다.

# 🌟 프로세스

## 프로세스의 개요

- = 작업(Job), 태스크(Task)
- 일반적으로 프로세서(처리기, CPU)에 의해 처리되는 사용자 프로그램, 시스템 프로그램, 즉 실행 중인 프로그램

### 프로세스의 정의

- PCB(printed circuit board; 인쇄 회로 기판)를 가진 프로그램
- 실기억장치에 저장된 프로그램
- 프로세서가 할당되는 실체로서, 디스패치가 가능한 단위
- 프로시저가 활동 중인 것
- 비동기적 행위를 일으키는 주체
- 지정된 결과를 얻기 위한 일련의 계통적 동작
- 목적 또는 결과에 따라 발생되는 사건들의 과정
- 운영체제가 관리하는 실행 단위

## PCB

- Process Control Block, 프로세스 제어 블록
- = Task Control Block, Job Control Block
- 운영체제가 프로세스에 대한 중요한 정보를 저장해 놓는 곳
- 각 프로세스가 생성될 때마다 고유의 PCB가 생성되고, 프로세스가 완료되면 PCB는 제거된다.

### PCB에 저장되어 있는 정보

- 프로세스의 현재 상태
- 포인터
  - 부모 프로세스에 대한 포인터
  - 자식 프로세스에 대한 포인터
  - 프로세스가 위치한 메모리에 대한 포인터
  - 할당된 자원에 대한 포인터
- 프로세스 고유 식별자
- 스케줄링 및 프로세스의 우선순위
- CPU 레지스터 정보
- 주기억장치 관리 정보
- 입·출력 상태 정보
- 계정 정보

## 프로세스 상태 전

### 프로세스 상태 전이의 개요

![image](https://github.com/JeongwooHam/FE_Study_Logs/assets/123251211/4e2e927b-7a80-464a-9b5a-4a70f8e17990)

- 프로세스가 시스템 내에 존재하는 동안 프로세스의 상태가 변하는 것
- 프로세스의 상태는 제출, 접수, 준비, 실행, 대기 상태로 나눌 수 있으며, 이 중 주요 세 가지 상태는 **준비, 실행, 대기 상태**이다.

#### 프로세스의 상태

> **제출**

- 작업을 처리하기 위해 사용자가 작업을 시스템에 제출한 상태

> **접수**

- 제출된 작업이 스풀 공간인 디스크의 할당 위치에 저장된 상태

> **준비**

- 프로세스가 프로세서를 할당받기 위해 기다리고 있는 상태

> **실행**

- 준비상태 큐에 있는 프로세스가 프로세서를 할당받아 실행되는 상태

> **대기, 보류, 블록**

- 프로세스에 입·출력 처리가 필요하면 현재 실행 중인 프로세스가 중단되고, 입·출력 처리가 완료될 때까지 대기하고 있는 상태

> **종료**

- 프로세스의 실행이 끝나고 프로세스 할당이 해제된 상태

### 프로세스 상태 전이 관련 용어

> **Dispatch**

- 준비 상태에서 대기하고 있는 프로세스 중 하나가 프로세서를 할당 받아 실행 상태로 전이되는 과정

> **Wake Up**

- 입·출력 작업이 완료되어 프로세스가 대기 상태에서 준비 상태로 전이 되는 과정

> **Spooling**

- 입·출력장치의 공유 및 상대적으로 느린 입·출력장치의 처리 속도를 보완하고 다중 프로그래밍 시스템의 성능을 향상시키기 위해 입·출력할 데이터를 직접 입·출력장치에 보내지 않고 나중에 한꺼번에 입·출력하기 위해 디스크에 저장하는 과정

> **Traffic Controller**

- 프로세스의 상태에 대한 조사와 통보를 담당함

## 스레드 (Thread)

- **프로세스 내에서의 작업 단위**로서 시스템의 여러 자원을 할당받아 실행하는 프로그램의 단위
- 하나의 프로세스에 하나의 스레드가 존재하는 경우에는 **단일 스레드**, 하나 이상의 스레드가 존재하는 경우 에는 **다중 스레드**
- 프로세스의 일부 특성을 갖고 있다. ➡️ **_경량(Light Weight) 프로세스_**
- 스레드 기반 시스템에서 스레드는 독립적인 스케줄링의 최소 단위로서 프로세스의 역할을 담당한다.
- 동일 프로세스 환경에서 서로 독립적인 다중 수행이 가능하다.

### 스레드의 분류

> 사용자 수준의 스레드

- 사용자가 만든 라이브러리를 사용하여 스레드를 운용함
- 속도는 빠르지만 구현이 어려움

> 커널 수준의 스레드

- 운영체제의 커널에 의해 스레드를 운용함
- 구현이 쉽지만 속도가 느림

### 스레드 사용의 장점

- 하나의 프로세스를 여러 개의 스레드로 생성하여 병행성을 증진시킬 수 있다.
- 하드웨어, 운영체제의 성능과 응용 프로그램의 처리율을 향상시킬 수 있다.
- 응용 프로그램의 응답 시간(Response Time)을 단축시킬 수 있다.
- 실행 환경을 공유시켜 기억장소의 낭비가 줄어든다.
- 프로세스들 간의 통신이 향상된다.
- 스레드는 공통적으로 접근 가능한 기억장치를 통해 효율적으로 통신한다.

## 주요 스케줄링 알고리즘

### FCFS = FIFO

- FIFS: First Come First Service, 선입 선출
- FIFO: First In First Out
- 준비상태 큐(대기 큐, 준비 완료 리스트, 작업준비 큐, 스케줄링 큐)에 도착한 순서에 따라 차례로 CPU를 할당하는 기법
- 가장 간단한 알고리즘
- 먼저 도착한 것이 먼저 처리되어 공평성은 유지되지만 짧은 작업이 긴 작업을, 중요한 작업이 중요하지 않은 작업을 기다리게 된다.

### SJF

- Shortest Job First, 단기 작업 우선
- 준비상태 큐에서 기다리고 있는 프로세스들 중에서 실행 시간이 가장 짧은 프로세스에게 먼저 CPU를 할당하는 기법
- 가장 적은 평균 대기 시간을 제공하는 최적 알고리즘

### HRN

- Hightest Response-ratio Next
- 실행 시간이 긴 프로세스에 불리한 SJF 기법을 보완하기 위한 것
- 대기 시간과 서비스(실행) 시간을 이용하는 기법
- 우선순위 계산 공식을 이용하여 서비스(실행) 시간이 짧은 프로세스나 대기 시간이 긴 프로세스에게 우선순위를 주어 CPU를 할당한다.
- 서비스 실행 시간이 짧거나 대기 시간이 긴 프로세스일 경우 우선순위가 높아진다.
- 우선순위를 계산하여 그 숫자가 가장 높은 것부터 낮은 순으로 우선순위가 부여된다.

> 우선순위 계산식

- `(대기시간 + 서비스시간) / (서비스시간)`

# 🌟 네트워크

## IP 주소

- 인터넷에 연결된 모든 컴퓨터 자원을 구분하기 위한 고유한 주소
- 숫자로 8비트씩 4부분, 총 32비트로 구성되어 있다.

### IP 주소의 구성

- 네트워크 부분의 길이에 따라 구분된다.

![image](https://github.com/JeongwooHam/FE_Study_Logs/assets/123251211/70147888-67b7-45dd-b8b1-5d3ab5d7f2c1)

## 서브네팅 (Subnetting)

- 할당된 네트워크 주소를 다시 여러 개의 작은 네트워크로 나누어 사용하는 것

### 서브넷 마스크(Subnet Mask)

- 4바이트의 IP 주소 중 네트워크 주소와 호스트 주소를 구분하기 위한 비트
- 이를 변경하여 네트워크 주소를 여러 개로 분할하여 사용한다.
- 서브넷 마스크는 각 클래스마다 다르게 사용된다.

## IPv4

- 헤더가 가변적이고, 주소크기는 32bit
- 유니캐스트/멀티캐스트/브로드캐스트 사용

## IPv6

### IPv6의 개요

- Internet Protocol version 6
- 현재 사용하고 있는 IP 주소 체계인 IPv4의 주소 부족 문제를 해결하기 위해 개발되었다.
- 인증성/기밀성/무결성 지원 (=보안성 강화)
- 유니캐스트, 애니캐스트, 멀티캐스트 사용
- 헤더의 경우는 40 octet의 고정된 길이를 가진다.
- 헤더가 40byte(320bit)로 고정되어 있고, 주소크기는 128bit

> **장점**

- 128비트의 긴 주소를 사용하여 주소 부족 문제를 해결할 수 있으며, IPv4에 비해 자료 전송 속도가 빠르다.
- 인증성, 기밀성, 데이터 무결성의 지원으로 보안 문제를 해결할 수 있다.
- IPv4와 호환성이 뛰어나다.
- 주소의 확장성, 융통성, 연동성이 뛰어나며, 실시간 흐름 제어로 향상된 멀티미디어 기능을 지원한다.
- 패킷 크기를 확장할 수 있으므로 패킷 크기에 제한이 없다.
- 확장 기능을 통해 보안 기능을 제공한다.
- 등급별, 서비스별로 패킷을 구분할 수 있어 품질 보장이 용이하다.

### IPv6의 구성

- **16비트**씩 8부분, 총 **128비트**로 구성되어 있다.
- 각 부분을 16진수로 표현하고, 콜론(`:`)으로 구분한다

#### IPv6의 주소 체계

> **Unicast**

- 단일 송신자와 단일 수신자 간의 통신(1 대 1 통신에 사용)

> **Multicast**

- 단일 송신자와 다중 수신자 간의 통신(1 대 다 통신에 사용)

> **Anycast**

- 단일 송신자와 가장 가까이 있는 단일 수신자 간의 통신(1 대 1 통신에 사용)

## 네트워크 관련 장비

### NIC

- 네트워크 인터페이스 카드; Network Interface Card
- 컴퓨터와 컴퓨터 또는 컴퓨터와 네트워크를 연결하는 장치
- 정보 전송 시 정보가 케이블을 통해 전송될 수 있도록 정보 형태를 변경함

### Hub

- 한 사무실이나 가까운 거리의 컴퓨터들을 연결하는 장치
- 각 회선을 통합적으로 관리하며, 신호 증폭 기능을 하는 리피터의 역할도 포함함
- 허브의 종류에는 더미 허브, 스위칭 허브가 있음

### Repeater

- 전송되는 신호가 전송 선로의 특성 및 외부 충격 등의 요인으로 인해 원래의 형태와 다르게 왜곡되거나 약해질 경우 원래의 신호 형태로 재생하여 다시 전송하는 역할을 수행함

### Bridge

- LAN과 LAN을 연결하거나 LAN 안에서의 컴퓨터 그룹(세그먼트)을 연결하는 기능
- 네트워크를 분산적으로 구성할 수 있어 보안성을 높일 수 있음

### Switch

- 브리지와 같이 LAN과 LAN을 연결하여 훨씬 더 큰 LAN을 만드는 장치
- 하드웨어를 기반으로 처리하므로 전송 속도가 빠름

### Router

- 브리지의 LAN과 LAN의 연결 기능에 데이터 전송의 최적 경로를 선택할 수 있는 기능이 추가된 것
- 서로 다른 LAN이나 LAN과 WAN의 연결도 수행함

### Gateway

- 전 계층(1~7계층)의 프로토콜 구조가 다른 네트워크의 연결을 수행함
- LAN에서 다른 네트워크에 데이터를 보내거나 다른 네트워크로부터 데이터를 받아들이는 출입구 역할을 함

# 📍 OSI 참조 모델

- 다른 시스템 간의 원활한 통신을 위해 ISO(국제표준화기구)에서 제안한 통신 규약(Protocol)

## OSI 7계층

### 하위 계층

- 물리 계층 → 데이터 링크 계층 → 네트워크 계층

> **물리 계층**

- 전송에 필요한 두 장치 간의 실제 접속과 절단 등 **기계적, 전기적, 기능적, 절차적 특성**에 대한 규칙을 정의함
- 프로토콜: Coax, Fiber, Wireless

> **데이터 링크 계층**

- 두 개의 인접한 개방 시스템들 간에 신뢰성 있고 효율적인 정보 전송을 할 수 있도록 시스템 간 **연결 설정과 유지 및 종료**를 담당함
- 송신 측과 수신 측의 속도 차이를 해결하기 위한 흐름 제어 기능을 함
- 프레임의 시작과 끝을 구분하기 위한 프레임의 동기화 기능을 함
- 오류의 검출과 회복을 위한 오류 제어 기능을 함
- 프로토콜: Ethernet, SLIP, PPP, FDDI, HDLC

> **네트워크 계층 (망 계층)**

- 개방 시스템들 간의 **네트워크 연결을 관리**하는 기능과 **데이터의 교환 및 중계** 기능을 함
- 네트워크 연결을 설정, 유지, 해제하는 기능을 함
- 경로 설정(Routing), 데이터 교환 및 중계, 트래픽 제어, 패킷 정보 전송을 수행함
- 프로토콜: IP, IPSec, ICMP, IGMP

### 상위 계층

- 전송 계층 → 세션 계층 → 표현 계층 → 응용 계층

> **전송 계층**

- 논리적 안정과 균일한 데이터 전송 서비스를 제공함으로써 종단 시스템(End-to-End) 간에 투명한 데이터 전송을 가능하게 함
- 종단 시스템(End-to-End) 간의 전송 연결 설정, 데이터 전송, 연결 해제 기능을 함
- 주소 설정, 다중화(분할 및 재조립), 오류 제어, 흐름 제어를 수행함
- 프로토콜: TCP, UDP, ECN, SCTP, DCCP

> **세션 계층**

- 송·수신 측 간의 관련성을 유지하고 대화 제어를 담당함
- 대화(회화) 구성 및 동기 제어, 데이터 교환 관리 기능을 함
- 프로토콜: VARIOUS APIS, SOCKETS

> **표현 계층**

- 응용 계층으로부터 받은 데이터를 세션 계층에 보내기 전에 통신에 적당한 형태로 변환하고, 세션 계층에서 받은 데이터는 응용 계층에 맞게 변환하는 기능을 함
- 서로 다른 데이터 표현 형태를 갖는 시스템 간의 상호 접속을 위해 필요한 계층
- 코드 변환, 데이터 암호화, 데이터 압축, 구문 검색, 정보 형식(포맷) 변환, 문맥 관리 기능을 함
- 프로토콜: SSL, FTP, IMAP, SSH

> **응용 계층**

- 사용자(응용 프로그램)가 OSI 환경에 접근할 수 있도록 서비스를 제공함
- 프로토콜: HTTP, FTP, IRC, SSH, DNS

# 🌟 프로토콜

- 컴퓨터 내부에서, 또는 컴퓨터 사이에서 데이터의 교환 방식을 정의하는 규칙 체계
- 교환 되는 데이터의 형식에 대해 상호 합의가 필요한 기기 간 통신의 교환 데이터 형식을 정의하는 규칙의 집합

## 응용 계층의 주요 프로토콜

### FTP

- File Transfer Protocol
- 컴퓨터와 컴퓨터 또는 컴퓨터와 인터넷 사이에서 파일을 주고받을 수 있도록 하는 원격 파일 전송 프로토콜

### SMTP

- Simple Mail Transfer Protocol
- 전자 우편을 교환하는 서비스

### TELNET

- 멀리 떨어져 있는 컴퓨터에 접속하여 자신의 컴퓨터처럼 사용할 수 있도록 해주는 서비스
- 프로그램을 실행하는 등 시스템 관리 작업을 할 수 있는 **가상의 터미널**(Virtual Terminal) 기능을 수행

### SNMP

- Simple Network Management Protocol
- TCP/IP의 네트워크 관리 프로토콜
- 라우터나 허브 등 네트워크 기기의 네트워크 정보를 네트워크 관리 시스템에 보내는 데 사용되는 표준 통신 규약

### DNS

- Domain Name System
- 도메인 네임을 IP 주소로 매핑(Mapping)하는 시스템

### HTTP

- HyperText Transfer Protocol
- 월드 와이드 웹(WWW)에서 HTML 문서를 송수신 하기 위한 표준 프로토콜

## 전송 계층의 주요 프로토콜

### TCP

- Transmission Control Protocol
- **양방향** **연결**(Full Duplex Connection)형 서비스를 제공함
- 스트림 위주의 전달(패킷 단위)을 함
- 신뢰성 있는 경로를 확립하고 메시지 전송을 감독함
- 순서 제어, 오류 제어, 흐름 제어 기능
- TCP 프로토콜의 헤더는 기본적으로 **20Byte에서 60Byte까지** 사용할 수 있는데, 선택적으로 40Byte를 더 추가할 수 있으므로 **최대 100Byte까지** 크기를 확장할 수 있음

### UDP

- User Datagram Protocol
- 데이터 전송 전에 연결을 설정하지 않는 **비연결형** 서비스를 제공함 + 비신뢰성
- TCP에 비해 상대적으로 단순한 헤더 구조
  - 오버헤드가 적고, 흐름제어나 순서 제어가 없어 전송 속도가 빠름
- 실시간 전송에 유리하다.
- 신뢰성보다는 속도가 중요시되는 네트워크에서 사용됨

### RTCP

- Real-Time Control Protocol
- RTP(Real-time Transport Protocol) 패킷의 전송 품질을 제어하기 위한 제어 프로토콜
- 세션(Session)에 참여한 각 참여자들에게 주기적으로 제어 정보를 전송함

## 인터넷 계층의 주요 프로토콜

### IP

- Internet Protocol
- 전송할 데이터에 주소를 지정하고, 경로를 설정하는 기능을 함
- **비연결형**인 데이터그램 방식을 사용하는 것으로 신뢰성이 보장되지 않음
- 체크섬 기능으로 헤더 체크섬만 제공한다.
- 패킷을 분할, 병합하는 기능을 수행하기도 한다.
- Best Effort 원칙에 따른 전송 기능을 제공한다.

### ICMP

- Internet Control Message Protocol, 인터넷 제어 메시지 프로토콜
- IP와 조합하여 통신 중에 발생하는 오류의 처리와 전송 경로 변경 등을 위한 제어 메시지를 관리하는 역할
- TCP/IP 계층 구조에서 IP의 동작 과정에서의 전송 오류가 발생하는 경우에 대비해 오류 경로를 전송하는 목적으로 사용하는 프로토콜
- 헤더는 **8Byte**로 구성됨

### IGMP

- Internet Group Management Protocol, 인터넷 그룹 관리 프로토콜
- 멀티캐스트를 지원하는 호스트나 라우터 사이에서 멀티캐스트 그룹 유지를 위해 사용됨

### ARP

- Address Resolution Protocol, 주소 분석 프로토콜
- 호스트의 IP 주소를 호스트와 연결된 네트워크 접속 장치의 물리적 주소 (**MAC Address**)로 바꿈
- IP 네트워크 상에서 IP 주소를 MAC 주소로 변환하는 프로토콜

### RARP

- Reverse Address Resolution Protocol
- ARP와 반대로 물리적 주소를 IP 주소로 변환하는 기능을 함

## 네트워크 엑세스 계층의 주요 프로토콜

### Ethernet (IEEE 802.3)

- CSMA/CD 방식의 LAN

> CSMA/CD

- Carrier Sense Multiple Access / Collision Detection
- 서로 알아서 눈치껏 통신하는 방

### IEEE 802

- LAN을 위한 표준 프로토콜

### HDLC

- 비트 위주의 데이터 링크 제어 프로토콜

### X.25

- 패킷 교환망을 통한 DTE와 DCE 간의 인터페이스를 제공하는 프로토콜

### RS-232C

- 공중 전화 교환망(PSTN)을 통한 DTE와 DCE 간의 인터페이스를 제공하는 프로토콜

> **DTE**

- Data Terminal Equipment
- 사용자-네트워크 인터페이스의 사용자 측에서 데이터 발신 장치나 수신 장치, 또는 두 가지 겸용으로 사용되는 장치
- 반드시 모뎀과 같은 DCE 장치를 통해 데이터 네트워크에 연결된다.
- DCE에 의해 생성된 클럭 처리 신호를 사용한다.
- 컴퓨터, 멀티 플렉서, 라우터 등의 장치를 포함한다.

> **DCE**

- Data Communication Equipment / Data Circuit-terminating Equipment
- 사용자-네트워크 인터페이스의 네트워크 측으로 구성되는 통신 네트워크 장비의 연결 수단
- 네트워크로 연결되는 물리적 수단이 된다.
- 트래픽을 전송하고 DCE 장치와 DTE 장치 사이에서 데이터 전송을 동기화하는 데 사용되는 클럭 신호를 제공한다.
- 모뎀과 인터페이스 카드를 포함한다.

# 📑 기타 기출 내용

## 알고리즘

### Dekker Algorithm

- 프로세스가 두개일때 상호 배제를 보장하는 최초의 알고리즘
- flag와 turn 변수를 사용하여 조정

### Lamport Algorithm

- 프로세스 n개의 상호 배제 문제를 해결한 알고리즘
- 프로세스에게 고유한 번호를 부여하고, 번호를 기준으로 우선순위를 정하여 우선순위가 높은 프로세스가 먼저 임계 구역에 진입하도록 구현

### Peterson Algorithm

- 프로세스가 두개일때 상호 배제를 보장
- 데커의 알고리즘과 유사하지만 상대방에게 진입 기회를 양보한다는 차이가 있고 보다 더 간단하게 구현됨

## Semaphore

- 공유된 자원의 데이터 혹은 임계영역 등에 따라 여러 Process 혹은 Thread가 접근하는 것을 막아줌(동기화 대상이 하나 이상)

## PPP

- 서로 다른 업체의 원격 액세스 소프트웨어들이 시리얼라인 상으로 서로 연결하여 TCP/IP 프로토콜로 통신할 수 있도록 만들기 위해 제정된 표준 규약

## RIP

- Routing Information Protocol
- 최단 경로 탐색에는 Bellman-Ford 알고리즘을 사용하는 거리 벡터 라우팅 프로토콜
- 라우팅 프로토콜을 IGP와 EGP로 분류했을 때 IGP에 해당한다.
- 최단경로탐색에는 Bellman-Ford 알고리즘을 사용한다.
- 최적의 경로를 산출하기 위한 정보로서 홉(거리 값)만을 고려하므로, RIP을 선택한 경로가 최적의 경로가 아닌 경우가 많이 발생할 수 있다.
- 소규모 네트워크 환경에 적합하다.
- 최대 홉 카운트를 15홉 이하로 한정하고 있다.

### AS

- 자율 시스템; Autonomous System
- 하나의 기관 내부를 나타내는 것으로 라우터들과 통신기기들의 집합. 예를 들면 하나의 학내망

### IGP

- Interior Gateway Protocol, 내부 게이트웨이 프로토콜
- 학내망 내부에서 라우팅하는것. 즉 하나의 AS 내에서의 라우팅에 사용되는 프로토콜
- RIP, OSPF

### EGP

- Exterior Gateway Protocol, 외부 게이트웨이 프로토콜
- 학내망과 다른 학내망의 라우팅에 사용. 즉 AS간의 라우팅에 사용되는 프로토콜
