# 🌟 프로세스

## 프로세스의 개요

- = 작업(Job), 태스크(Task)
- 일반적으로 프로세서(처리기, CPU)에 의해 처리되는 사용자 프로그램, 시스템 프로그램, 즉 실행 중인 프로그램

### 프로세스의 정의

- PCB(printed circuit board; 인쇄 회로 기판)를 가진 프로그램
- 실기억장치에 저장된 프로그램
- 프로세서가 할당되는 실체로서, 디스패치가 가능한 단위
- 프로시저가 활동 중인 것
- 비동기적 행위를 일으키는 주체
- 지정된 결과를 얻기 위한 일련의 계통적 동작
- 목적 또는 결과에 따라 발생되는 사건들의 과정
- 운영체제가 관리하는 실행 단위

## PCB

- Process Control Block, 프로세스 제어 블록
- = Task Control Block, Job Control Block
- 운영체제가 프로세스에 대한 중요한 정보를 저장해 놓는 자료구조 테이블
- 각 프로세스가 생성될 때마다 고유의 PCB가 생성되고, 프로세스가 완료되면 PCB는 제거된다.
- 프로세스 식별자, 프로세스 상태 등의 정보로 구성된다.

> **문맥 교환**

- context switching
- CPU가 현재 실행하고 있는 프로세스의 상태를 PCB에 저장하고 다음 프로세스의 PCB로부터 문맥을 복원하는 작업

### PCB에 저장되어 있는 정보

- 프로세스의 현재 상태
- 포인터
  - 부모 프로세스에 대한 포인터
  - 자식 프로세스에 대한 포인터
  - 프로세스가 위치한 메모리에 대한 포인터
  - 할당된 자원에 대한 포인터
- 프로세스 고유 식별자
- 스케줄링 및 프로세스의 우선순위
- CPU 레지스터 정보
- 주기억장치 관리 정보
- 입·출력 상태 정보
- 계정 정보

## 프로세스 상태 전

### 프로세스 상태 전이의 개요

![image](https://github.com/JeongwooHam/FE_Study_Logs/assets/123251211/4e2e927b-7a80-464a-9b5a-4a70f8e17990)

- 프로세스가 시스템 내에 존재하는 동안 프로세스의 상태가 변하는 것
- 프로세스의 상태는 제출, 접수, 준비, 실행, 대기 상태로 나눌 수 있으며, 이 중 주요 세 가지 상태는 **준비, 실행, 대기 상태**이다.

#### 프로세스의 상태

> **제출**

- 작업을 처리하기 위해 사용자가 작업을 시스템에 제출한 상태

> **접수**

- 제출된 작업이 스풀 공간인 디스크의 할당 위치에 저장된 상태

> **준비**

- 프로세스가 프로세서를 할당받기 위해 기다리고 있는 상태

> **실행**

- 준비상태 큐에 있는 프로세스가 프로세서를 할당받아 실행되는 상태

> **대기, 보류, 블록**

- 프로세스에 입·출력 처리가 필요하면 현재 실행 중인 프로세스가 중단되고, 입·출력 처리가 완료될 때까지 대기하고 있는 상태

> **종료**

- 프로세스의 실행이 끝나고 프로세스 할당이 해제된 상태

### 프로세스 상태 전이 관련 용어

> **Dispatch**

- 준비 상태에서 대기하고 있는 프로세스 중 하나가 프로세서를 할당 받아 실행 상태로 전이되는 과정

> **Wake Up**

- 입·출력 작업이 완료되어 프로세스가 대기 상태에서 준비 상태로 전이 되는 과정

> **Spooling**

- 입·출력장치의 공유 및 상대적으로 느린 입·출력장치의 처리 속도를 보완하고 다중 프로그래밍 시스템의 성능을 향상시키기 위해 입·출력할 데이터를 직접 입·출력장치에 보내지 않고 나중에 한꺼번에 입·출력하기 위해 디스크에 저장하는 과정

> **Traffic Controller**

- 프로세스의 상태에 대한 조사와 통보를 담당함

## 스레드 (Thread)

- **프로세스 내에서의 작업 단위**로서 시스템의 여러 자원을 할당받아 실행하는 프로그램의 단위
- 하나의 프로세스에 하나의 스레드가 존재하는 경우에는 **단일 스레드**, 하나 이상의 스레드가 존재하는 경우 에는 **다중 스레드**
- 프로세스의 일부 특성을 갖고 있다. ➡️ **_경량(Light Weight) 프로세스_**
- 스레드 기반 시스템에서 스레드는 독립적인 스케줄링의 최소 단위로서 프로세스의 역할을 담당한다.
- 동일 프로세스 환경에서 서로 독립적인 다중 수행이 가능하다.

### 스레드의 분류

> 사용자 수준의 스레드

- 사용자가 만든 라이브러리를 사용하여 스레드를 운용함
- 속도는 빠르지만 구현이 어려움

> 커널 수준의 스레드

- 운영체제의 커널에 의해 스레드를 운용함
- 구현이 쉽지만 속도가 느림

### 스레드 사용의 장점

- 하나의 프로세스를 여러 개의 스레드로 생성하여 병행성을 증진시킬 수 있다.
- 하드웨어, 운영체제의 성능과 응용 프로그램의 처리율을 향상시킬 수 있다.
- 응용 프로그램의 응답 시간(Response Time)을 단축시킬 수 있다.
- 실행 환경을 공유시켜 기억장소의 낭비가 줄어든다.
- 프로세스들 간의 통신이 향상된다.
- 스레드는 공통적으로 접근 가능한 기억장치를 통해 효율적으로 통신한다.

## 주요 스케줄링 알고리즘

### FCFS = FIFO

- FIFS: First Come First Service, 선입 선출
- FIFO: First In First Out
- 준비상태 큐(대기 큐, 준비 완료 리스트, 작업준비 큐, 스케줄링 큐)에 도착한 순서에 따라 차례로 CPU를 할당하는 기법
- 가장 간단한 알고리즘
- 먼저 도착한 것이 먼저 처리되어 공평성은 유지되지만 짧은 작업이 긴 작업을, 중요한 작업이 중요하지 않은 작업을 기다리게 된다.

### SJF

- Shortest Job First, 단기 작업 우선
- 준비상태 큐에서 기다리고 있는 프로세스들 중에서 실행 시간이 가장 짧은 프로세스에게 먼저 CPU를 할당하는 기법
- 가장 적은 평균 대기 시간을 제공하는 최적 알고리즘

### HRN

- Hightest Response-ratio Next
- 실행 시간이 긴 프로세스에 불리한 SJF 기법을 보완하기 위한 것
- 대기 시간과 서비스(실행) 시간을 이용하는 기법
- 우선순위 계산 공식을 이용하여 서비스(실행) 시간이 짧은 프로세스나 대기 시간이 긴 프로세스에게 우선순위를 주어 CPU를 할당한다.
- 서비스 실행 시간이 짧거나 대기 시간이 긴 프로세스일 경우 우선순위가 높아진다.
- 우선순위를 계산하여 그 숫자가 가장 높은 것부터 낮은 순으로 우선순위가 부여된다.

> 우선순위 계산식

- `(대기시간 + 서비스시간) / (서비스시간)`

### SSTF

- Shortest Seek Time First
- 현재 디스크의 헤드 위치에서 가장 가까운 실린더에 대한 요청을 우선적으로 처리한다.
- 가장 가까운 것 = 가장 이동 거리가 짧은 것 = 현재 트랙과 남아있는 트랙 중 차이가 적은 것

### SLTF

- Shortest Latency Time First
- 회전 지연 시간 최적화를 위한 대표적 알고리즘
- 디스크 헤드가 특정 실린더에 독착하면 그 실린더 내의 여러 트랙에 대한 요청들을 검사한 후 회전 지연 시간이 가장 짧은 요청부터 서비스하는 기법

### SCAN

- 디스크의 한 쪽 끝에서 반대쪽 끝으로 이동하면서 처리한다.
- 마지막 실린더에 도착하면 반대 방향으로 스캔을 진행한다.
