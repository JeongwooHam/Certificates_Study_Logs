# 🌟 소프트웨어 아키텍처 설계

## 상위 설계와 하위 설계

### 상위 설계

- 아키텍쳐 설계, 예비 설계
- 설계 대상
  - 시스템의 전체적인 구조
- 세부 목록
  - 구조, DB, 인터페이스

### 하위 설계

- 모듈 설계, 상세 설계
- 설계 대상
  - 시스템의 내부 구조 및 행위
- 세부 목록
  - 컴포넌트, 자료 구조, 알고리즘

## 소프트웨어 아키텍처 설계의 기본 원리

### 모듈화

- 소프트웨어의 성능을 향상시키거나 시스템의 수정 및 재사용, 유지 관리 등이 용이하도록 시스템의 기능들을 모듈 단위로 나누는 것

### 추상화

- 문제의 전체적이고 포괄적인 개념을 설계한 후 차례로 세분화하여 구체화 시켜 나가는 것
- 과정 추상화, 데이터, 추상화, 제어 추상화로 구분된다.

### 단계적 분해

- Nilaus Wirth에 의해 제안된 하향식 설계 전략
- 문제를 상위의 중요 개념으로부터 하위의 개념으로 구체화시키는 분할 기법

### 정보 은닉

- 한 모듈 내부에 포함된 절차와 자료들의 정보가 감추어져 다른 모듈들이 접근하거나 변경하지 못하도록 하는 기법

## 소프트웨어 아키텍처의 품질 속성

- 소프트웨어 아키텍처가 이해 관계자들이 요구하는 수준의 품질을 유지 및 보장할 수 있게 설계되었는지를 확인하기 위해 품질 평가 요소들을 구체화시켜 놓은 것

> **시스템 측면**

- 성능, 보안, 가용성, 기능성, 사용성, 변경 용이성, 확장성

```
독립성은 포함되지 않는다!
```

> **비즈니스 측면**

- 시장 적시성, 비용과 혜택, 예상 시스템 수명

> **아키텍쳐 측면**

- 개념적 무결성, 정확성, 완결성, 구축 가능성

## 소프트웨어 아키텍처의 설계 과정

> **1. 설계 목표 설정**

- 시스템의 개발 방향을 명확히 하기 위해 설계에 영향을 주는 비즈니스 목표, 우선 순위 등의 요구 사항을 분석하여 전체 시스템의 설계 목표를 설정한다.

> **2. 시스템 타입 결정**

- 시스템과 서브 시스템 타입을 결정한다.
- 설계 목표와 함께 고려하여 아키텍쳐 패턴을 선택한다.

> **3. 아키텍쳐 패턴 적용**

- 아키텍쳐 패턴을 참조하여 시스템의 표준 아키텍쳐를 설계한다.

> **서브 시스템 구체화**

- 서브 시스템의 기능 및 서브 시스템 간의 상호 작용을 위한 동작과 인터페이스를 정의한다.

> **검토**

- 아키텍처가 설계 목표에 부합하는지
- 요구 사항이 잘 반영되었는지
- 설계의 기본 원리를 만족하는지

## 협약에 의한 설계

- 컴포넌트 설계 시 클래스에 대한 여러 가정을 공유할 수 있도록 명세한 것
- 소프트웨어 컴포넌트에 대한 정확한 인터페이스를 명세한다.

### 협약에 의한 설계 시 명세에 포함될 조건

> **선행 조건**

- 오퍼레이션이 호출되기 전에 참이 되어야 할 조건

> **결과 조건**

- 오퍼레이션이 수행된 후 만족되어야 할 조건

> **불변 조건**

- 오퍼레이션이 실행되는 동안 항상 만족되어야 할 조건

## 아키텍처 패턴

### 파이프 - 필터 패턴

![image](https://github.com/JeongwooHam/FE_Study_Logs/assets/123251211/164560d9-e5bc-47fa-a165-167f85993c08)

- 데이터 스트림 절차의 각 단계를 필터 컴포넌트로 캡슐화하여 파이프를 통해 데이터를 전송하는 패턴
- 시스템이 입력 데이터를 받아 처리하고 결과를 다른 시스템에 보내는 작업이 반복되는 아키텍처 스타일
- 데이터는 파이프를 통해 단방향으로 흐르고 필터 이동 시 오버헤드가 발생할 수 있다.
- 단방향, 양방향 모두 구현할 수 있다.
- 필터 컴포넌트
  - 재사용성이 좋고 추가가 쉬워 확장이 용이하다.
- 필터 컴포넌트들을 재배치하여 다양한 파이프라인을 구축하는 것이 가능하다.
- 데이터 변환, 버퍼링, 동기화 등에 주로 사용된다.
- 예: UNIX의 쉘

### 모델 - 뷰 - 컨트롤러 패턴 (MVC)

![image](https://github.com/JeongwooHam/FE_Study_Logs/assets/123251211/63af3025-1a58-4f63-b7dc-2305a5d09f54)

- 서브 시스템을 3개의 부분으로 구조화하는 패턴
- 대화형 어플리케이션에 적합하다.
- 사용자 인터페이스를 담당하는 계층의 응집도를 높일 수 있다.
- 여러 개의 다른 UI를 만들어 그 사이에 결합도를 낮출 수 있다.

> 모델

- 서브 시스템의 핵심 기능과 데이터를 보관한다.

> 뷰

- 사용자에게 정보를 표시한다.
- 한 개의 모델에 대해 여러 개의 뷰를 만들 수 있다.
- 모델에 있는 데이터를 사용자 인터페이스에 보여주는 역할을 담당한다.

> 컨트롤러

- 사용자로부터 입력된 변경 요청을 처리하기 위해 모델에게 명령을 보낸다.
- 모델과 뷰 사이에서 전달자 역할을 한다.

### 기타 패턴

> 마스터-슬레이브 패턴

- 마스터 컴포넌트에서 슬레이브 컴포넌트로 작업을 분할한 후 슬레이브 컴포넌트에서 처리된 결과물을 다시 돌려받는 방식으로 작업을 수행하는 패턴
- 장애 허용 시스템, 병렬 컴퓨팅 시스템에서 활용됨
- 슬레이브는 마스터의 작업 요청을 처리하고 처리한 결과를 되돌려준다.
- 마스터는 슬레이브가 반환한 결과값으로부터 최종 결과값을 계산한다.
- 네임 노드(마스터)는 데이터 노드(슬레이브)에 대한 메타 데이터를 가지고 있다.

> 브로커 패턴

- 사용자가 원하는 서비스와 특성을 브로커 컴포넌트에 요청 시 브로커 컴포넌트가 요청에 맞는 컴포넌트와 사용자를 연결해주는 패턴
- 분산 환경 시스템에서 활용됨

> 피어-투-피어 패턴

- 피어를 하나의 컴포넌트로 간주한다.
- 각 피어는 서비스를 호출하는 클라이언트가 될 수도, 서비스를 제공하는 서버가 될 수도 있다.

> 이벤트-버스 패턴

- 소스가 특정 채널에 이벤트 메시지를 발행하면 해당 채널을 구독한 리스너들이 메시지를 받아 이벤트를 처리하는 방식

> 블랙보드 패턴

- 모든 컴포넌트들이 공유 데이터 저장소와 블랙보드 컴포넌트에 접근이 가능한 형태
- 컴포넌트들은 검색을 통해 블랙보드에서 원하는 데이터를 찾을 수 있다.
- 음성 인식, 차량 식별, 신호 해석 등

> 인터프리터 패턴

- 프로그램 코드의 각 라인을 수행하는 방법을 지정하고 기호마다 클래스를 갖도록 구성된다.
