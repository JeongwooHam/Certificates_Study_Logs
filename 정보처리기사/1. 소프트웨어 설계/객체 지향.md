# 🌟 객체 지향

## 객체

- 데이터와 데이터를 처리하는 함수를 묶어놓은(캡슐화한) 하나의 소프트웨어 모듈
- 상태, 동작, 고유 식별자를 가진 모든 것
- 필요한 자료 구조와 이에 수행되는 함수들을 가진 하나의 독립된 존재
- 객체의 상태는 속성값에 의해 정의된다.

### 데이터

- 객체가 가지고 있는 정보
- 속성, 상태, 분류, 변수, 상수, 자료 구조

### 함수

- 객체가 수행하는 기능
- 객체가 갖는 데이터(속성, 상태)를 처리하는 알고리즘
- 객체의 상태를 참조하거나 변경하는 수단이 되는 것
- 메소드(행위), 서비스, 동작, 연산

### 객체의 특성

- 독립적으로 식별 가능한 이름을 가지고 있다.
- 상태
  - 객체가 가질 수 있는 조건
  - 시간에 따라 변한다.
- 객체와 객체는 상호 연관성에 의한 관계가 형성된다.
- 행위
  - 객체가 반응할 수 있는 메시지의 집합
  - 객체는 행위의 특징을 나타낼 수 있다.
- 일정한 기억 장소를 가지고 있다.
- 객체의 메소드는 다른 객체로부터 메시지를 받았을 때 정해진 기능을 수행한다.

## 클래스

- 공통된 속성과 연산(행위)을 갖는 _객체의 집합_
- 객체의 일반적인 타입
- 각각의 객체들이 갖는 속성과 연산을 정의하고 있는 틀
- 객체 지향 프로그램에서 데이터를 추상화하는 단위

> **인스턴스**

- 클래스에 속한 각각의 객체

> **인스턴스화**

- 클래스로부터 새로운 객체를 생성하는 것

## 캡슐화

- 데이터(속성)와 데이터를 처리하는 함수를 하나로 묶는 것
- 캡슐화된 객체는 인터페이스를 제외한 세부 내용이 은폐(정보 은닉)된다.
  - 외부에서의 접근이 제한적이다.
  - 외부 모듈의 변경으로 인한 파급 효과가 적다.
- 캡슐화된 객체들은 재사용이 용이하다.
- 객체들 간의 메시지를 주고 받을 때 상대 객체의 세부 내용은 알 필요가 없다.
  - 인터페이스가 단순해진다.
  - 객체 간 결합도가 낮아진다.

## 상속

- 이미 정의된 상위 (부모) 클래스의 모든 속성과 연산을 하위 (자식) 클래스가 물려 받는 것
- 하위 클래스는 상위 클래스의 모든 속성과 연산을 자신의 클래스 내에 다시 정의하지 않고도 즉시 자신의 속성으로 사용할 수 있다.
- 하위 클래스는 상위 클래스로부터 상속 받은 속성과 연산 외에 새로운 속성과 연산을 첨가하여 사용할 수 있다.

## 다형성

- 메시지에 의해 객체(클래스)가 연산을 수행하게 될 때 하나의 메시지에 대해 각각의 객체(클래스)가 가지고 있는 고유한 방법(특성)으로 응답할 수 있는 능력
- 객체(클래스)들은 동일한 메소드명을 사용하며 같은 의미의 응답을 한다.
- 응용 프로그램 상에서 하나의 함수나 연산자가 두 개 이상의 서로 다른 클래스의 인스턴스들을 같은 클래스에 속한 인스턴스처럼 수행할 수 있도록 하는 것
- 현재 코드를 변경하지 않고 새로운 클래스를 쉽게 추가할 수 있게 한다.
- 여러 가지 형태를 가지고 있다는 의미로, 여러 형태를 받아들일 수 있는 특징을 말한다.

### 다형성 사례

- `+` 연산자
  - 숫자 클래스에서는 덧셈 기능
  - 문자 클래스에서는 문자열의 연결 기능
- 오버로딩 기능
  - _메소드의 이름은 같지만_ 인수를 받는 자료형과 개수를 달리 하여 여러 기능을 정의할 수 있다.
- 오버 라이딩 (메소드 재정의) 기능
  - 상속 관계에서만 발생한다.
  - 상위 클래스에서 정의한 _메소드의 이름은 같지만_ 메소드 안의 실행 코드를 달리하여 자식 클래스에서 재정의하여 사용할 수 있다.
  - 슈퍼클래스의 메서드를 서브클래스에서도 동일하게 재정의하는 것

## 연관성

- 두 개 이상의 객체(클래스)들이 상호 참조하는 관계

### 연관성의 종류

> **`is member of`**

- 연관화
- 2개 이상의 객체가 상호 관련되어 있음

> **`is instance of`**

- 분류화
- 동일한 형의 특성을 갖는 객체들을 모아 구성하는 것

> **`is part of`**

- 집단화
- 관련 있는 객체들을 묶어 하나의 상위 객체를 구성하는 것

> **`is a`**

- 일반화
  - 공통적인 성질들로 추상화한 상위 객체를 구성하는 것
- 특수화 / 상세화
  - 상위 객체를 구체화하여 하위 객체를 구성하는 것

## 객체 지향 분석의 방법론

### Rumbaugh(럼바우) 방법

- 객체 모델링 기법 (OMT; Object-Modeling Technique)
- 가장 일반적으로 사용 되는 방법
- 모든 소프트웨어 구성 요소를 그래픽 표기법을 이용하여 모델링하는 기법
- 분석 활동을 객체 모델링 ➡️ 동적 모델링 ➡️ 기능 모델로 나누어 수행하는 방법

> **객체 모델링**

- 정보 모델링
- 시스템에서 요구되는 객체를 찾아내어 속성, 연산 식별 및 객체들 간의 관계를 규정해 객체 다이어그램으로 표시하는 것

> **동적 모델링**

- 상태 다이어그램(상태도)을 이용해 시간의 흐름에 따른 객체들 간의 제어 흐름, 상호 작용, 동작 순서 등의 동적인 행위를 표현하는 모델링

> **기능 모델링**

- 자료 흐름도(DFD)를 이용해 다수의 프로세스들 간의 자료 흐름을 중심으로 처리 과정을 표현한 모델링

### Booch(부치) 방법

- 미시적 개발 프로세스와 거시적 개발 프로세스를 모두 사용하는 분석 방법
- 클래스와 객체들을 분석 및 식별하고 클래스의 속성과 연산을 정의한다.

### Jacobson 방법

- 유스케이스를 강조하여 사용하는 분석 방법

### Coad와 Yourdon 방법

- E-R 다이어그램을 사용하여 객체의 행위를 모델링한다.
- 객체 식별, 구조 식별, 주제 정의, 속성과 인스턴스 연결 정의, 연산과 메시지 연결 정의 등의 과정으로 구성하는 기법

### Wirfs-Brock 방법

- 분석과 설계 간의 구분이 없다.
- 고객 명세서를 평가하여 설계 작업까지 연속적으로 수행하는 기법

## 객체 지향 설계 원칙 (SOLID)

- 시스템 변경이나 확장에 유현한 시스템을 설계하기 위해 지켜야 할 다섯 가지 원칙

### S: 단일 책임 원칙

- SRP: Single Responsibility Principle
- 객체는 단 하나의 책임만 가져야 한다.

### O: 개방-폐쇄 원칙

- OCP: Open Closed Principle
- 기존의 코드를 변경하지 않고 기능을 추가할 수 있도록 설계되어야 한다.

### L: 리스코프 치환 원칙

- LSP: Liskov Substitution Principle
- 자식 클래스는 최소한 자신의 부모 클래스에서 가능한 행위는 수행할 수 있어야 한다.

### I: 인터페이스 분리 원칙

- ISP: Interface Segregation Principle
- 자신이 사용하지 않는 인터페이스와 의존 관계를 맺거나 영향을 받지 않아야 한다.

### D: 의존 역전 원칙

- DIP: Dependency Inversion Principle
- 각 객체들 간의 의존 관계 성립 시 추상성이 낮은 클래스보다 추상성이 높은 클래스와 의존 관계를 맺어야 한다.

# 📍 결합도

![image](https://github.com/JeongwooHam/FE_Study_Logs/assets/123251211/55ecfbfa-ba69-4af6-be86-e6077c2df464)

- 모듈 간에 상호 의존하는 정도 또는 두 모듈 사이의 연관 관계
- 다양한 결합으로 모듈을 구성할 수 있다.
  - 결합도가 약할수록 품질이 높다.
  - 결합도가 강할수록 품질이 낮다.
  - 결합도가 강하면 시스템 구현 및 유지보수 작업이 어렵다.

## 결합도의 종류 (내 - 공 - 외 - 제 - 스 - 자)

> **자료 결합도 (Data Coupling)**

- 모듈 간의 인터페이스가 자료 요소로만 구성될 때의 결합도

> **스탬프(검인) 결합도 (Stamp Coupling)**

- 모듈 간의 인터페이스로 배열이나 레코드 등의 자료 구조가 전달될 때의 결합도

> **제어 결합도 (Control Coupling)**

- 어떤 모듈이 다른 모듈 내부의 논리적인 흐름을 제어하기 위해 제어 신호를 이용하여 통신하거나 제어 요소(Function Code, Switch, Tag, Flag)를 전달하는 결합도

> **외부 결합도 (External Coupling)**

- 어떤 모듈에서 선언한 데이터(변수)를 외부의 다른 모듈에서 참조할 때의 결합도

> **공통(공유) 결합도 (Common Coupling)**

- 공유되는 공통 데이터 영역을 여러 모듈이 사용할 때의 결합도

> **내용 결합도 (Content Coupling)**

- 한 모듈이 다른 모듈의 내부 기능 및 그 내부 자료를 직접 참조하거나 수정할 때의 결합도

# 📍 응집도

![image](https://github.com/JeongwooHam/FE_Study_Logs/assets/123251211/fe29f83b-5c56-4a52-9e9f-4d471a655b16)

- 정보 은닉 개념을 확장한 것
- 명령어나 호출문 등 모듈의 내부 요소들의 서로 관련되어 있는 정도
- 모듈이 독립적인 기능으로 정의 되어 있는 정도
- 다양한 기준으로 모듈을 구성할 수 있다.
  - 응집도가 강할수록 품질이 높다.
  - 응집도가 약할수록 품질이 낮다.

## 응집도의 종류 (기 - 순 - 교 - 절 - 시 - 논 - 우)

> **기능적 응집도 (Functional Cohesion)**

- 모듈 내부의 모든 기능 요소들이 단일 문제와 연관되어 수행될 경우의 응집도

> **순차적 응집도 (Sequential Cohesion)**

- 모듈 내 하나의 활동으로부터 나온 출력 데이터를 그 다음 활동의 입력 데이터로 사용할 경우의 응집도

> **교환(통신)적 응집도 (Communication Cohesion)**

- 동일한 입력과 출력을 사용하여 서로 다른 기능을 수행하는 구성 요소들이 모였을 경우의 응집도

> **절차적 응집도 (Procedural Cohesion)**

- 모듈이 다수의 관련 기능을 가질 때 모듈 안의 구성 요소들의 그 기능을 순차적으로 수행할 경우의 응집도

> **시간적 응집도 (Temporal Cohesion)**

- 특정 시간에 처리되는 몇 개의 기능을 모아 하나의 모듈로 작성할 경우의 응집도

> **논리적 응집도 (Logical Cohesion)**

- 유사한 성격을 갖거나 특정 형태로 분류되는 처리 요소들로 하나의 모듈이 형성되는 경우의 응집도

> **우연적 응집도 (Coincidental Cohesion)**

- 모듈 내부의 각 구성 요소들이 서로 관련 없는 요소로만 구성된 경우의 응집도

# 📍 재사용

- 비용과 개발 시간을 절약하기 위해 이미 개발된 기능들을 파악하고 재구성하여 새로운 시스템 또는 기능 개발에 사용하기 적합하도록 최적화 시키는 작업
- 재사용을 위해서
  - 누구나 이해할 수 있고 사용이 가능하도록 사용법을 공개해야 한다.
- 재사용되는 대상
  - 외부 모듈과의 결합도가 낮아야 한다.
  - 응집도가 높아야 한다.

## 재사용 규모에 따른 분류

> **함수와 객체**

- 클래스나 메소드 단위의 소스 코드를 재사용한다.

> **컴포넌트**

- 독립적인 업무 또는 기능을 수행하는 실행 코드 기반으로 작성된 모듈
- 컴포넌트 자체에 대한 수정 없이 인터페이스를 통해 통신하는 방식으로 재사용
- 명백한 역할을 가지고 독립적으로 존재할 수 있는 시스템의 부분
- 넓은 의미에서는 재사용되는 모든 단위라고 볼 수 있으며 인터페이스를 통해서만 접근할 수 있다.

> **애플리케이션**

- 공통된 기능들을 제공하는 애플리케이션을 공유하는 방식으로 재사용
