# 🌟 알고리즘

## 알고리즘

- 주어진 작업을 수행하는 컴퓨터 명령어를 순서대로 나열한 것

## 검색

- 정렬이 되지 않은 데이터 혹은 정렬이 된 데이터 중에서 키 값에 해당되는 데이터를 찾는 알고리즘
- 흩어져있는 데이터를 키값을 이용하여 순서대로 열거하는 알고리즘
- 이진 검색: 검색 수행 전 데이터의 집합이 정렬되어 있어야 한다.
- 선형 검색: 처음부터 끝까지 하나씩 순서대로 비교하며 원하는 값을 찾아내는 검색

## 정렬

### 삽입 정렬 (Insertion Sort)

- 자료 배열의 모든 요소를 앞에서부터 차례대로 이미 정렬된 배열 부분과 비교하여, 자신의 위치를 찾아 삽입함으로써 정렬을 완성하는 알고리즘
- 두 번째 자료부터 시작하여 그 앞(왼쪽)의 자료들과 비교하여 삽입할 위치를 지정한 후 자료를 뒤로 옮기고 지정한 자리에 자료를 삽입하여 정렬하는 알고리즘

### 선택 정렬 (Selection Sort)

1. 주어진 리스트 중에 최소값을 찾는다.
2. 그 값을 맨 앞에 위치한 값과 교체한다(패스(pass)).
3. 맨 처음 위치를 뺀 나머지 리스트를 같은 방법으로 교체한다.

### 버블 정렬 (Bubble Sort)

- 서로 인접한 두 원소를 검사하여 정렬하는 알고리즘
- 인접한 2개의 레코드를 비교하여 크기가 순서대로 되어 있지 않으면 서로 교환한다.

### 퀵 정렬 (Quick Sort)

- 레코드의 많은 자료 이동을 없애고 하나의 파일을 부분적으로 나누어 가면서 정렬하는 방법
- 키를 기준으로 작은 값은 왼쪽에, 큰 값은 오른쪽 서브파일로 분해시키는 방식
- 분할(Divide)과 정복(Conquer)을 통해 자료를 정렬한다.
- 평균 수행 시간 복잡도는 **O(nlog2n)**, 최악의 수행 시간 복잡도는 **O(n2)**이다.

> **구현 방법**

1. 주어진 배열에서 하나의 요소를 선택하고 이를 **pivot(피벗)** 으로 삼는다.
2. 배열 내부의 모든 값을 검사하면서 피벗 값보다 작은 값들은 왼쪽에, 큰 값들은 오른쪽에 배치한다.
3. 이렇게 하면 배열이 두 부분으로 나뉜다. 나뉜 이 두 개의 배열에서 각각 새로운 피벗을 만들어서 두 개의 배열로 다시 쪼개어 준다.
4. 더 이상 배열을 쪼갤 수 없을 때까지 진행한다.

### 힙 정렬 (Heap Sort)

- 완전이진 트리(Complete Binary Tree)를 이용한 정렬 방식
- 구성된 완전이진 트리를 Heap Tree로 변환하여 정렬한다.
- 정렬할 입력 레코드들로 힙을 구성하고 가장 큰 키 값을 갖는 루트 노드를 제거하는 과정을 반복하여 정렬하는 기법
- 평균과 최악 모두 시간 복잡도는 **O(nlog2n)**
- [자료구조 개념 이해하기 '힙과 힙 정렬 알고리즘'](https://yozm.wishket.com/magazine/detail/2312/)

> **HEAP**

- 최댓값 및 최솟값을 찾아내는 연산을 빠르게 하기 위해 고안된 완전이진트리를 기본으로 한 자료구조
- A가 B의 부모노드 이면, A의 키값과 B의 키값 사이에는 대소관계가 성립한다.

### 2-Way 합병 정렬 (Merge Sort)

- 이미 정렬되어 있는 두 개의 파일을 한 개의 파일로 합병하는 정렬 방식
- 평균과 최악 모두 시간 복잡도는 **O(nlog2n)**

## 이분 검색

- = 이진 검색, Binary Search
- 전체 파일을 두 개의 서브 파일로 분리해 가면서 Key 레코드를 검색하는 방식
- 이분 검색은 반드시 순서화된 파일이어야 검색할 수 있다.
  - 데이터 목록은 반드시 사전에 **오름차순**으로 정렬되어 있어야 한다.
- 찾고자 하는 Key 값을 파일의 중간 레코드 Key 값과 비교하면서 검색한다.
- 비교 횟수를 거듭할 때마다 검색 대상이 되는 데이터의 수가 절반으로 줄어듦으로 탐색 효율이 좋고 탐색 시간이 적게 소요된다.
- 중간 레코드 번호 `M = (F+L)/2`
  - (단, F : 첫 번째 레코드 번호, L : 마지막 레코드 번호)

### 이진 검색 동작 방식

1. 배열의 중간 값을 찾음
2. 중간 값과 검색 값을 비교
   2-1. 중간 값이 검색 값과 같으면 끝.
   2-2. 중간 값보다 검색 값이 크다면 오른쪽 구간을 탐색
   2-3. 중간 값보다 검색 값이 작다면 왼쪽 구간을 탐색 3.값을 찾거나 간격이 비었을 때까지 반복
